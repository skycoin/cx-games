package entity
import "game"



var mm f32 // movement multiplier 
var velocityInc f32
var pixelSpanX f32
var pixelSpanY f32
var gradientSpan f32
var currFrame f64



// entities

var numEnts i32 = 2 //4
var SnakeId i32
var X []f32
var Y []f32

var VelX []f32 // velocity
var VelY []f32

var Rad []f32 // radius 
var Expiry []f64
var Dead []bool

var Red []f32
var Green []f32
var Blue []f32



// chain of entities 
// (used to plot a variable amount of spheres from point A to point B)
var ChainLength f32 // distance between end/A/B points 
var ChainProgress f32 // current fraction along chain's length (0.0 - 1.0) 


// spots/points 
var /* point */ AX f32
var /* point */ AY f32
var /* radius */ ARad f32
var /* point */ BX f32
var /* point */ BY f32
var /* radius */ BRad f32

// ---- deltas from point A to point B 
var DelX f32
var DelY f32
var DelRad f32



func Init() () {
	str.print("--- entity.Init()")

	pixelSpanX = 2.0 / i32.f32(game.Width)
	pixelSpanY = 2.0 / i32.f32(game.Height)
	gradientSpan = 1.0 / 300.0

	for i := 0; i < numEnts; i++ {
		x := game.ScreenBoundsLeft   + i32.f32(i32.rand(0, game.Width + 1)) * pixelSpanY
		y := game.ScreenBoundsBottom + i32.f32(i32.rand(0, game.Height + 1)) * pixelSpanY
		vx := i32.f32(i32.rand(-50, 51)) * game.AsteroidVelocityGrain
		vy := i32.f32(i32.rand(-50, 51)) * game.AsteroidVelocityGrain

		if i == SnakeId {
			x = 0.0
			y = 0.0
			vx = 0.005
			vy = 0.005
		}

		SpawnEntity(x, y, vx, vy, 0.1, 0.0D)
	}
}


var prevFrame f64
func Update() () {
 	currFrame   = glfw.GetTime()
 	deltaFrame := f64.f32(currFrame - prevFrame) 
 	mm          = deltaFrame * 200.0
 	velocityInc = deltaFrame / 50.0

	// per frame  
	for i := 0; i < []f32.len(X); i++ {
		// per relevant entity 			
		if IsAlive(i) {
			// movement
			vx := []f32.read(VelX, i) 
			vy := []f32.read(VelY, i)

			if /* moving */ vx != 0.0 || vy != 0.0 {
				// new spot 
				x := []f32.read(X, i) + vx * mm
				y := []f32.read(Y, i) + vy * mm

				// teleport objects to the opposite edge when they leave the screen
				if x < game.ScreenBoundsLeft {
					x = game.ScreenBoundsRight
				}

				if x > game.ScreenBoundsRight {
					x = game.ScreenBoundsLeft
				}

				if y > game.ScreenBoundsTop {
					y = game.ScreenBoundsBottom
				}

				if y < game.ScreenBoundsBottom {
					y = game.ScreenBoundsTop
				}

				[]f32.write(X, i, x)
				[]f32.write(Y, i, y)

				IsTouching_WillExplode(i)
			}
		}
	}

	prevFrame = currFrame
}


func SetupChainFromAToB(
	aX f32, aY f32, aRad f32, 
	bX f32, bY f32, bRad f32,
	isSnakeEntity bool) () {

	AX = aX;
	AY = aY;
	ARad = aRad;
	BX = bX
	BY = bY
	BRad = bRad

	DelX := bX - aX 
	DelY := bY - aY
	DelRad := bRad - aRad



	// overlap spheres by about half their radius.		
	ChainProgress = 0.0 // current spot in distance spectrum (0.0 - 1.0) 
	
	if isSnakeEntity {
		ChainLength = f64.f32(game.CurrSnakeExtent) * 2.0
	} else {
		ChainLength = game.GetDistance(aX, aY, bX, bY)
	}
}


func AdvanceChainProgressBy(inc f32) () {
	ChainProgress += inc
}


func IsTouching_WillExplode(moverId i32) (out bool) {
	touching := false
	// moving entity spot/radius 
	mX := []f32.read(X, moverId)
	mY := []f32.read(Y, moverId)
	mRad := []f32.read(Rad, moverId)


	for i := 0; i < []f32.len(X); i++ {
		// per relevant 
		if IsAlive(i) && i != moverId {
			// current entity spot/radius 
			cX := []f32.read(X, i)
			cY := []f32.read(Y, i)
			cRad := []f32.read(Rad, i) // ...radius 

			touchSpan := cRad + mRad
			dist := game.GetDistance(cX, cY, mX, mY)
			
			if dist < touchSpan {
				if moverId == 0 {
					f32.print(dist)
				}

				touching = true

				[]f64.write(Expiry, i, currFrame)
				[]f64.write(Expiry, moverId, currFrame)
			}
		}
	}

	return touching
}


func IsAlive(i i32) (out bool) {
	e := []f64.read(Expiry, i)

	if e == 0.0D || e > currFrame {
		return true
	}

	return false
}


func Shoot(index i32) () {
	fraction := 0.05D

	x := []f32.read(X, index)
	y := []f32.read(Y, index) 
	velX := f64.f32(game.CurrSnakeExtent * f64.cos(game.CurrSnakeAim) * fraction)
	velY := f64.f32(game.CurrSnakeExtent * f64.sin(game.CurrSnakeAim) * fraction)

	SpawnEntity(x, y, velX, velY,
		0.015, // radius
		glfw.GetTime() + 0.5D) // expiry
}


func SpawnEntity(x f32, y f32, velX f32, velY f32, rad f32, expiry f64) () {
	spawnNew := true

	// reserving 0 for player's snake (all other slots up for recycling)
	for i := 1; i < []f32.len(X); i++ {
		if []bool.read(Dead, i) == true {
			[]bool.write(Dead, i, false)
			[]f32.write(X, i, x)
			[]f32.write(Y, i, y)
			[]f32.write(VelX, i, velX)
			[]f32.write(VelY, i, velY)
			[]f32.write(Rad, i, rad)
			[]f32.write(Expiry, i, expiry)
			spawnNew = false
			// set color?
		}
	}

	if spawnNew {
		Dead = []bool.append(Dead, false)

		X = []f32.append(X, x)
		Y = []f32.append(Y, y)
		
		VelX = []f32.append(VelX, velX)
		VelY = []f32.append(VelY, velY)
		
		Rad = []f32.append(Rad, rad)
		Expiry = []f64.append(Expiry, expiry)

		Red =   []f32.append(Red, i32.f32(i32.rand(0, 200) + 100) * gradientSpan)
		Green = []f32.append(Green, i32.f32(i32.rand(0, 200) + 100) * gradientSpan)
		Blue =  []f32.append(Blue, i32.f32(i32.rand(0, 200) + 100) * gradientSpan)	
	}
}












var maxVelocity f32 = 0.01
var maxNegativeVelocity f32 = -0.01

func ForcePositiveVelocityAndBloomIt(index i32, inX bool) () {
	if inX {
		[]f32.write(VelX, index, boundedIncrease([]f32.read(VelX, index)))
	} else { // in y
		[]f32.write(VelY, index, boundedIncrease([]f32.read(VelY, index)))
	}
}

func ForceNegativeVelocityAndBloomIt(index i32, inX bool) () {
	if inX {
		[]f32.write(VelX, index, boundedDecrease([]f32.read(VelX, index)))
	} else { // in y
		[]f32.write(VelY, index, boundedDecrease([]f32.read(VelY, index)))
	}
}


func SlowDownInAxis(index i32, inX bool) () {
	if inX {
		[]f32.write(VelX, 0, rampDownToStop([]f32.read(VelX, 0)))
	} else { // in y 
		[]f32.write(VelY, 0, rampDownToStop([]f32.read(VelY, 0)))
	}
}


func boundedDecrease(vel f32) (out f32) {
	if vel > 0.0 {
		vel = 0.0
	}

	vel -= velocityInc

	if vel < maxNegativeVelocity {
		vel = maxNegativeVelocity
	}

	return vel
}


func boundedIncrease(vel f32) (out f32) {
	if vel < 0.0 {
		vel = 0.0
	}

	vel += velocityInc

	if vel > maxVelocity {
		vel = maxVelocity
	}

	return vel
}


func rampDownToStop(vel f32) (out f32) {
	/* multiplier */ m := 2.0

	if vel > 0.0 { // increasing value
		vel -= velocityInc * m

		if vel < 0.0 {
			vel = 0.0
		}
	}

	if vel < 0.0 { // decreasing value
		vel += velocityInc * m

		if vel > 0.0 {
			vel = 0.0
		}
	}

	return vel
}
