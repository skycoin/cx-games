package ccInput        // "input" must be reserved?  got errors until I renamed this

import "glfw"

import "main"
import "entity"
import "game"



var currMouseX f64
var currMouseY f64

var GLFW_KEY_5     i32 = 53
var GLFW_KEY_SPACE i32 = 32

// directional keys 
var	GLFW_KEY_A i32 = 65
var	GLFW_KEY_D i32 = 68
var	GLFW_KEY_W i32 = 87
var	GLFW_KEY_S i32 = 83

// move direction 
var moveLeft bool
var moveRight bool
var moveUp bool
var moveDown bool



func Init() () {
	glfw.SetKeyCallback("window", "onKeyEvent")
	glfw.SetMouseButtonCallback("window", "onMouseButtonEvent")
	glfw.SetCursorPosCallback("window", "onCursorPosEvent")
}


func Update() () {
	// snake motion input status 
	moveLeft  = keyIsDown(GLFW_KEY_A)
	moveRight = keyIsDown(GLFW_KEY_D)
	moveUp    = keyIsDown(GLFW_KEY_W)
	moveDown  = keyIsDown(GLFW_KEY_S)
	SetSnakeVelocity()
}


// mouse buttons 

func onMouseButtonEvent(window str, key i32, action i32, mods i32) () {
	if action == /* Press */ 1 {
		if game.Mode >= game.MODE_Playing {
			entity.Shoot(0)
		} else { // must be in menu 
			btn := game.GetButtonThatPointerIsTouching(currMouseX, currMouseY)
			str.print(btn)

			if btn == "Play" {
				game.SetMode(game.MODE_Playing)
				glfw.SetInputMode("window", glfw.Cursor, glfw.CursorDisabled)
			} /*else { // FIXME when CX gets switches 
				if btn == "Options" {
					game.SetMode(game.MODE_OptionsMenu)
					glfw.SetInputMode("window", glfw.Cursor, glfw.CursorEnabled)
					game.ButtonNames = []str.append(game.ButtonNames, "Mouse Sensitivity (Horizontal)")
					game.ButtonNames = []str.append(game.ButtonNames, "Mouse Sensitivity (Vertical)")
				}
			} */

		}
	}
}



// mouse position

var prevMouseX f64
var prevMouseY f64
func onCursorPosEvent(window str, x f64, y f64) () {
	currMouseX = x
	currMouseY = y

	if prevMouseX != 0.0D && prevMouseY != 0.0D { // not the 1st time (delta unknown)
		if game.Mode >= game.MODE_Playing {
			deltaX := x - prevMouseX
			deltaY := y - prevMouseY
			// invert from pixel to world aligned space 
			// (value increases going up the screen)
			deltaY = 0.0D - deltaY 

			//a := str.concat("cursor event delta ---- x ", f64.str(deltaX))
			//b := str.concat(", y "                      , f64.str(deltaY))
			//str.print(str.concat(a, b))

			game.SetSnakeAimAndSize(
				f64.f32(deltaX),
				f64.f32(deltaY))
		}
	}
	
	prevMouseX = x
	prevMouseY = y
}



// keys

func onKeyEvent(window str, key i32, scancode i32, action i32, mods i32) () {
	// action == 0, release 
	// action == 1, press 
	// action == 2, is an autorepeat event, generated by keys that are held longer than a second

	if key == GLFW_KEY_5 {
		glfw.SetShouldClose("window", true)
	}



	if /* not a repeat */ action != 2 {
		if key == GLFW_KEY_SPACE && action == 1 {
			entity.Shoot(0)
		}
	}
}


func keyIsDown(key i32) (out bool) {
	// GetKey() never gives a "repeat" action (only gives 0 & 1)

	if glfw.GetKey("window", key) == 1 {
		return true
	}

	return false
}


func SetSnakeVelocity() () {
	// horizontal 

	if moveLeft {
		entity.ForceNegativeVelocityAndBloomIt(0, true)
	} else {
		if moveRight {
			entity.ForcePositiveVelocityAndBloomIt(0, true)
		} else {
			entity.SlowDownInAxis(0, true)
		}
	}
	


	// vertical 

	if moveDown {
		entity.ForceNegativeVelocityAndBloomIt(0, false)
	} else {
		if moveUp {
			entity.ForcePositiveVelocityAndBloomIt(0, false)
		} else {
			entity.SlowDownInAxis(0, false)
		}
	}
}

