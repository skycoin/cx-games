package main

import "gl"
import "glfw"
import "game"
import "entity"

var dubPi f32



func main () () {
	dubPi = 2.0 * 3.141592654
	entity.Init()



	glfw.Init()
	glfw.CreateWindow("window", game.Width, game.Height, game.Name)
	glfw.MakeContextCurrent("window")
	glfw.SetKeyCallback("window", "onKeyEvent")
	
	gl.Init()
	program := gl.CreateProgram()
	gl.LinkProgram(program)


	ball = new Ball{
		radius: 0.05,
		x: 0.0,
		y: 0.0,
		vx: 0.01,
		vy: 0.01,
		gravity: 0.01
	}

	head = new Ball{
		radius: 0.07,
		x: 0.1,
		y: 0.1,
		vx: 0.0,
		vy: 0.0,
		gravity: 0.01
	}

	var ratio f32

	for not(glfw.ShouldClose("window")) {
		bufferWidth, bufferHeight := glfw.GetFramebufferSize("window")
		ratio = f32.div(i32.f32(bufferWidth), i32.f32(bufferHeight))

		gl.Clear(gl.COLOR_BUFFER_BIT)

		gl.UseProgram(program)
		
		gl.MatrixMode(gl.PROJECTION)
		gl.LoadIdentity()
		gl.Ortho(f32.mul(ratio, -1.0), ratio, -1.0, 1.0, 1.0, -1.0)
		gl.MatrixMode(gl.MODELVIEW)

		respondToCollisions()
		moveObjects()
		draw(ball)


		
		glfw.PollEvents()
		glfw.SwapBuffers("window")
	}
}














//game
type Ball struct {
	x f32
	y f32
	vx f32
	vy f32
	gravity f32
	radius f32
}

var ball Ball
var head Ball



func respondToCollisions() () {
	if ball.x + ball.radius <= -1.0 {
		ball.vx += ball.gravity
	} 

	if ball.x + ball.radius >= 1.0 {
		ball.vx -= ball.gravity
	}

	if ball.y + ball.radius <= -1.0 {
		ball.vy = f32.abs(ball.vy)
	} else {
		ball.vy -= ball.gravity
	}
}


var velocityInc f32 = 0.001
var maxVelocity f32 = 0.01
var maxNegativeVelocity f32 = -0.01
func moveObjects() () {
	if headMoveLeft {
		head.vx -= velocityInc

		if head.vx < maxNegativeVelocity {
			head.vx = maxNegativeVelocity
		}
	} 
	
	if headMoveRight {
		head.vx += velocityInc

		if head.vx > maxVelocity {
			head.vx = maxVelocity
		}
	} 



	if !headMoveLeft && !headMoveRight {
		if head.vx > 0.0 {
			head.vx -= velocityInc

			if head.vx < 0.0 {
				head.vx = 0.0
			}
		}

		if head.vx < 0.0 {
			head.vx += velocityInc

			if head.vx > 0.0 {
				head.vx = 0.0
			}
		}
	}




	if headMoveDown {
		head.vy -= velocityInc

		if head.vy < maxNegativeVelocity {
			head.vy = maxNegativeVelocity
		}
	} 
	
	if headMoveUp {
		head.vy += velocityInc

		if head.vy > maxVelocity {
			head.vy = maxVelocity
		}
	} 



	if !headMoveUp && !headMoveDown {
		if head.vy > 0.0 {
			head.vy -= velocityInc

			if head.vy < 0.0 {
				head.vy = 0.0
			}
		}

		if head.vy < 0.0 {
			head.vy += velocityInc

			if head.vy > 0.0 {
				head.vy = 0.0
			}
		}
	}




	head.x += head.vx
	head.y += head.vy
	
	// tail
	ball.x += ball.vx
	ball.y += ball.vy
}


func draw(ball Ball) () {
	numSegments := 6
	xOff /* head offset from the tail */ := head.x - ball.x
	yOff /* head offset from the tail */ := head.y - ball.y
	xSpan /* between segments */ := xOff / i32.f32(numSegments)
	ySpan /* between segments */ := yOff / i32.f32(numSegments)

	for j := 0; j <= numSegments; j++ {
		drawBall(
			ball.x + xSpan * i32.f32(j), 
			ball.y + ySpan * i32.f32(j), 
			ball.radius,
			1.0,
			1.0,
			1.0)
	}

	for i := 0; i < entity.numEnts; i++ {
		drawBall(
			[]f32.read(entity.entitiesX, i), 
			[]f32.read(entity.entitiesY, i), 
			0.016,
			[]f32.read(entity.Red, i), 
			[]f32.read(entity.Green, i), 
			[]f32.read(entity.Blue, i))
	}
}


func drawBall(x f32, y f32, radius f32, red f32, green f32, blue f32) () {
	gl.Begin(gl.POLYGON)
	gl.Color3f(red, green, blue)

	for i := 0; i < 20; i++ {
		finalX := x + radius * f32.cos(i32.f32(i) * dubPi / 20.0)
		finalY := y + radius * f32.sin(i32.f32(i) * dubPi / 20.0)

		gl.Vertex2f(finalX, finalY)
	}

	gl.End()
}













//input
var GLFW_KEY_5 i32 = 53

var	GLFW_KEY_A i32 = 65
var	GLFW_KEY_D i32 = 68
var	GLFW_KEY_W i32 = 87
var	GLFW_KEY_S i32 = 83

var	GLFW_KEY_I i32 = 73
var GLFW_KEY_J i32 = 74
var GLFW_KEY_K i32 = 75
var GLFW_KEY_L i32 = 76

var headMoveLeft bool
var headMoveRight bool
var headMoveUp bool
var headMoveDown bool

var tailMoveLeft bool
var tailMoveRight bool
var tailMoveUp bool
var tailMoveDown bool

func onKeyEvent (window str, key i32, scancode i32, action i32, mods i32) () {
	if /* press */ action == 1 {
		if /* left */ key == 263 {
			ball.vx = -0.03
		}

		if /* right */ key == 262 {
			ball.vx = 0.03
		}

		if key == GLFW_KEY_5 {
			glfw.SetShouldClose("window", true)
		}



		// snake head motion 
		if key == GLFW_KEY_J {
			headMoveLeft = true
		}

		if key == GLFW_KEY_L {
			headMoveRight = true
		}

		if key == GLFW_KEY_I {
			headMoveUp = true
		}

		if key == GLFW_KEY_K {
			headMoveDown = true
		}
	} 

	if /* release */ action == 0 {
		// snake head motion 
		if key == GLFW_KEY_J {
			headMoveLeft = false
		}

		if key == GLFW_KEY_L {
			headMoveRight = false
		}

		if key == GLFW_KEY_I {
			headMoveUp = false
		}

		if key == GLFW_KEY_K {
			headMoveDown = false
		}
	}
}


func keyCurrentlyDown() (out bool) {
	return true
}