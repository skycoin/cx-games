package draw

// common  
import "gl"
import "gltext"

// game 
import "entity"
import "game"



// special angle nums 
var pi           f32
var halfPi       f32
var oneThirdPie  f32 // 1/3 of a whole PIE (the food, not the number) 
var twoThirdsPie f32

// precalculated lookup table for unit radius sphere points/vertices 
var numSpherePoints            i32 = 20
var spherePointsAngleIncrement f32
var spherePointsX              []f32
var spherePointsY              []f32



func Init() () {
	str.print("--- draw.Init()")

	// special angle nums 
	pi = 3.141592654
	halfPi = pi / 2.0
	game.SetDubPi(pi * 2.0)
	oneThirdPie = game.DubPi / 3.0
	twoThirdsPie = oneThirdPie * 2.0
	spherePointsAngleIncrement = game.DubPi / i32.f32(numSpherePoints)

	setupFonts()
	setupSpherePointTable()
}


func setupSpherePointTable() () {
	f := 0.0

	for i := 0; i < numSpherePoints; i++ {
		spherePointsX = []f32.append(spherePointsX, f32.sin(f))
		spherePointsY = []f32.append(spherePointsY, f32.cos(f))

		f += spherePointsAngleIncrement
	}
}


func All() () { // draw all 
	/*
	
	x, y := game.GetPosOfPerfectRadiusVisualizer()
	Sphere(x, y, 0.07, 1.0, 0.0, 0.0)	

	x, y := game.GetPosOfBoxyDistanceVisualizer()
	Sphere(x, y, 0.07, 0.0, 1.0, 0.0)	
	
	*/

	/* draw */ Snake()
	/* draw */ Entities()
	/* draw */ Text()
	/* draw */ menuMaybe()

}


func Entities() () {
	// skipping 0 (reserved for player entity), which has it's own draw func. 
	// for now, all else are spheres 
	for i := 1; i < []f32.len(entity.X); i++ {
		if entity.IsAlive(i) {
			Sphere(
				[]f32.read(entity.X, i), 
				[]f32.read(entity.Y, i), 
				[]f32.read(entity.Rad, i),
				[]f32.read(entity.Red, i), 
				[]f32.read(entity.Green, i), 
				[]f32.read(entity.Blue, i))
		}
	}
}


func Sphere(x f32, y f32, radius f32, red f32, green f32, blue f32) () {
	gl.Begin(gl.POLYGON)
	gl.Color3f(red, green, blue)

	
	for i := 0; i < numSpherePoints; i++ {
		gl.Vertex2f(
			x + radius * []f32.read(spherePointsX, i),
			y + radius * []f32.read(spherePointsY, i))
	}

	gl.End()
}


func orientedSphere(
	step i32, // the decimated stride thru indices 
	x f32, 
	y f32, 
	radius f32, 
	angle f32, 
	red f32, green f32, blue f32) () {

	/*
	*/
	// might return 



	gl.Begin(gl.POLYGON)
	gl.Color3f(red, green, blue)

	// insane number (goes outside of valid index range, requires sanitizing)
	startIdx := 0
	if spherePointsAngleIncrement > 0.0 {
		startIdx = f32.i32(angle / spherePointsAngleIncrement)
	}

	// (FIXME if perfection is needed later... should "round" instead of
	// effectively "floor"ing, which means subtracting half a radian grain?) 
	max := numSpherePoints + startIdx

	for i := startIdx; i < max; i += step {
		si := i // sane index 

		for si >= numSpherePoints {
			si -= numSpherePoints
		}

		gl.Vertex2f(
			x + radius * []f32.read(spherePointsX, si),
			y + radius * []f32.read(spherePointsY, si))
	}

	gl.End()
}


func Triangle(x f32, y f32, radius f32, angle f32, red f32, green f32, blue f32) () {
	gl.Begin(gl.POLYGON)
	gl.Color3f(red, green, blue)

	aX := radius * f32.sin(angle)
	aY := radius * f32.cos(angle)
	bX := radius * f32.sin(angle + oneThirdPie)
	bY := radius * f32.cos(angle + oneThirdPie)
	cX := radius * f32.sin(angle + twoThirdsPie)
	cY := radius * f32.cos(angle + twoThirdsPie)

	gl.Vertex2f(x + aX, y + aY)
	gl.Vertex2f(x + bX, y + bY)
	gl.Vertex2f(x + cX, y + cY)

	gl.End()
}


func Snake() () {
	sin := f32.sin(game.CurrSnakeAim)
	cos := f32.cos(game.CurrSnakeAim) 

	// head/tail deltas (from center of snake) 
	xOff := game.CurrSnakeExtent * sin
	yOff := game.CurrSnakeExtent * cos
	
	// center pos 
	cX := []f32.read(entity.X, entity.SnakeId)
	cY := []f32.read(entity.Y, entity.SnakeId)

	// tail pos 
	tX := cX - xOff
	tY := cY - yOff

	// head pos 
	hX := cX + xOff
	hY := cY + yOff
	


	entity.SetupChainFromAToB(
		// tail 
		tX, 
		tY, 
		game.TailRadius, 

		// head 
		hX, 
		hY, 
		game.HeadRadius,

		true)

	// draw head 
	//Sphere(entity.BX, entity.BY, game.HeadRadius, 0.0, 0.0, 1.0)
	Triangle(entity.BX, entity.BY, game.HeadRadius, game.CurrSnakeAim, 0.0, 0.0, 1.0)

	drawIndicators(sin, cos)

	// draw rotation (center hinge) point 
	Sphere(cX, cY, game.HeadRadius / 3.0, 0.0, 0.0, 1.0)



	// draw body 

	for entity.ChainProgress <= entity.ChainLength {
		// fraction towards destination 
		ftd := entity.ChainProgress / entity.ChainLength
		
		// current radius 
		cRad := game.TailRadius + ftd * entity.DelRad

		orientedSphere(
			5,
			tX + ftd * entity.DelX, 
			tY + ftd * entity.DelY, 
			cRad, 
			game.CurrSnakeAim,
			1.0, 1.0, 1.0)

		entity.AdvanceChainProgressBy(cRad)
	}
}


func Text() () {
	// maybe draw top-of-screen text 
	if game.EventTextTimeFadeStarts != 0.0 && // (text has expiry set &...) 
		game.EventTextColorIntensity > 0.0 {  // (...still has color) 

		gl.Color4f(
			game.EventTextColorIntensity, 
			0.0, //game.EventTextColorIntensity, // made it white at the time 
			game.EventTextColorIntensity, 
			1.0)

		gltext.Printf(
			"Roboto50", 
			game.EventTextX,
			game.EventTextY, 
			game.EventText)

		//gltext.Printf("Roboto100", 0.0, 0.0, "Hello World")
	}

	if game.Mode >= game.MODE_Playing {
		s := "mouse + W A S D      5"
		// everlasting text 
		//EntityChainedText([]f32.read(entity.X, 0), []f32.read(entity.Y, 0), 0.0, 0.0, s) // ...that moves with player 

		// stationary 
		f := 0.4
		gl.Color4f(f, f, f, 1.0)
		gltext.Printf(
			"Roboto50", 
			game.ScreenCenterXInGltextSpace, 
			i32.f32(game.ScreenNumPixelsHigh - 1) - game.TextHeight, 
			s)
	}
}


func EntityChainedText(x f32, y f32, offsetX f32, offsetY f32, s str) () {
	// dynamic text space positions 
	midX := i32.f32(game.ScreenNumPixelsWide) / 2.0
	midY := i32.f32(game.ScreenNumPixelsHigh) / 2.0
	dfc /* distance from center */ := x / game.ScreenBoundsRight
	x := offsetX + midX + midX * dfc
	y := offsetY + i32.f32(game.ScreenNumPixelsHigh) - (y - game.ScreenBounds.Bottom) * midY

	gl.Color4f(0.8, 0.0, 0.8, 1.0)
	gltext.Printf("Roboto50", x, y, s)
}



// private 

func setupFonts() () {
	wd := os.GetWorkingDirectory()
	fontFile := str.concat(wd, "fonts/roboto-light.ttf")

	os.Open(fontFile)
	gltext.LoadTrueType("Roboto100", fontFile, 100, 32, 127, gltext.LeftToRight)
	os.Close(fontFile)
	
	os.Open(fontFile)
	gltext.LoadTrueType("Roboto50", fontFile, f32.i32(game.TextHeight), 32, 127, gltext.LeftToRight)
	os.Close(fontFile)

	gl.Enable(gl.DEPTH_TEST)
	gl.DepthFunc(gl.LESS)
	gl.ClearColor(0.1, 0.1, 0.1, 0.0)
}


func drawIndicators(sin f32, cos f32) () {
	ie /* indicator extent */ := game.HeadRadius / 4.0
	rfc /* radius from center (of head) */ := ie + game.HeadRadius
	hoX /* head offset */ := sin * rfc
	hoY /* head offset */ := cos * rfc
	
	// shrink 
	ci := game.GetShrinkColorIntensity()
	Triangle(
		entity.BX - hoX, 
		entity.BY - hoY, 
		ie, 
		game.CurrSnakeAim + pi,
		ci, 0.0, 1.0)
	
	// grow 
	ci = game.GetGrowColorIntensity()
	Triangle(
		entity.BX + hoX, 
		entity.BY + hoY, 
		ie, 
		game.CurrSnakeAim,
		ci, 0.0, 1.0)

	// rotate negative 
	qqX, qqY := game.RotatePositionByAngle(
		hoX,
		hoY,
		halfPi)

	ci = game.GetRotateNegativelyColorIntensity()
	Triangle(
		entity.BX + qqX, 
		entity.BY + qqY, 
		ie, 
		game.CurrSnakeAim - halfPi,
		ci, 0.0, 1.0)

	// rotate positive 
	qqX, qqY = game.RotatePositionByAngle(
		hoX,
		hoY,
		0.0 - halfPi)
	
	ci = game.GetRotatePositivelyColorIntensity()
	Triangle(
		entity.BX + qqX, 
		entity.BY + qqY, 
		ie, 
		game.CurrSnakeAim + halfPi,
		ci, 0.0, 1.0)
}


func menuMaybe() () {
	if game.Mode < game.MODE_Playing {
		f := 1.0
		gl.Color4f(f, f, f, 1.0)

		y := game.DeltaFromTop

		for i := 0; i < []str.len(game.ButtonNames); i++ {
			gltext.Printf(
				"Roboto50", 
				game.ScreenCenterXInGltextSpace, 
				y, 
				[]str.read(game.ButtonNames, i))	

			y += game.TextHeight
		}
	}
}