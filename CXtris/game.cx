package main

import "app"
import "draw"
import "gameDraw"
import "gameTime"
import "inputs"
import "map"
import "menu"
import "space"



func StartNewGameSession () {
	inputs.LatestUserActionTime = 0.0D
	
	shape.Next = i32.rand(0, shape.SHAPE_MAX)
	map.EmptyPlayfield()
 	shape.SpawnNew()
	
	// spawn any wanted random debris blocks 
	for     y := 0; y < menu.DebrisHeight; y++ {
		for x := 0; x < map.NUM_CELLS_X;   x++ {
			if i32.rand(0, 2) == 0 {
				map.Cells[y][x] = i32.rand(0, shape.SHAPE_MAX)
			}
		}
	}
}


func initGame () {
	shape.Init()
	space.Init()
	draw.Init()
	gameDraw.Init()
	inputs.Init()
	inputs.BufferingPointerSpots = true
	inputs.BufferingNotchyDeltas = true
	StartNewGameSession()
}


func update () {
	respondToKeyEvents()
	respondToButtonEvents()
	respondToPointerEvents()
	respondToNotchyMouseDeltas()
}


func respondToKeyEvents () {
	var key    i32
	var action i32
	key, action = inputs.GetKeyEvent ()

	if action == glfw.Press {
		oneTimeOnly(key)
		repeaters(key)
	}else
	if action == glfw.Repeat { // (generated by keys that are held longer than ___) 
		repeaters(key)
	}else
	if action == glfw.Release {
	}
}


func respondToButtonEvents () {
	var button i32
	var action i32
	button, action = inputs.GetButtonEvent ()
		
	if action == glfw.Repeat { // (generated by buttons that are held longer than ___) 
	}else
	if action == glfw.Release {
	}else 
	if action == glfw.Press {
		if button == glfw.MouseButtonLeft {
			if app.Mode < app.MODE_MENU_MAX { // in a menu 
				respondToMenuClicks()
			}
			
			shape.PlayerRotate(-1)
		}else
		if button == glfw.MouseButtonRight {
			shape.PlayerRotate(1)
		}else 
		if button == glfw.MouseButtonMiddle {
		}
	}
}


func respondToNotchyMouseDeltas () {
	var v app.Vec2I = inputs.GetNotchyMouseDelta ()
	
	if v.X != app.MAX_I32 {
		if v.Y > 0 { // only allow moving shape down 
			v.Y = 0
		}
		
		shape.MoveByOffset(v.X, v.Y)
	}
}


func oneTimeOnly (key i32) {
	if inputs.OpenedMenu(key) {
		StartNewGameSession()
	}else
	if inputs.EventRotateLeft(key) {
		shape.PlayerRotate(-1)
	}else
	if inputs.EventRotateRight(key) {
		shape.PlayerRotate(1)			
	}else{
		inputs.CloseAppOnDeveloperShortcut(key)
	}
}


func repeaters (key i32) {
	if app.Mode == app.MODE_PLAYING {
		if inputs.EventLeft(key) {
			shape.MoveByOffset(-1, 0)
		}else
		if inputs.EventRight(key) {
			shape.MoveByOffset(1, 0)
		}else
		if inputs.EventUp(key) {
			// NO NEED TO MOVE UP 
		}else
		if inputs.EventDown(key) {
			shape.MoveByOffset(0, -1)
		}
	}
}


func respondToPointerEvents () {
	var v app.Vec2 = inputs.GetPointerEvent ()
		
	// allow dragging a slider handle 
	if inputs.HoldingLeftButton && 
		v.X != app.TOO_BIG_F32 &&
		app.Mode <= app.MODE_MENU_OPTIONS {
			
		respondToMenuDrags()
	}
}


func respondToMenuDrags () {
	var s str
	var i i32
	s, i = menu.GetHoveredItem(app.Mode)

	/*
	if s == menu.ItemText {
		menu.Setting = menu.SetSliderValue(i, f64.f32(MousePointerX64))
	} else
	*/
	if s == menu.DebrisHeightText {
		menu.DebrisHeight = menu.SetSliderValue(i, f64.f32(inputs.MousePointerX64))
		StartNewGameSession()
	} else
	if s == menu.SpeedText {
		gameTime.DropSpeed =    menu.SetSliderValue(i, f64.f32(inputs.MousePointerX64))
		gameTime.CalcDropTime()
	}
}


func respondToMenuClicks () {
	var s str
	var i i32
	s, i = menu.GetHoveredItem(app.Mode)

	if s == menu.Play {
		inputs.SetMousePointer(false)
		shape.PlayerScore    =  0
		shape.PlayerScoreTxt = "0"
		StartNewGameSession()
		app.Mode = app.MODE_PLAYING
	} else
	if s == menu.Options {
		app.Mode = app.MODE_MENU_OPTIONS
	} else
	if s == menu.Controls {
		app.Mode = app.MODE_MENU_CONTROLS
	} else
	if s == menu.Quit {
		glfw.SetShouldClose(app.Name, true)
	} else
	if s == menu.ShowNextShapeText + "YES" {
		    menu.ShowNextShape = false
		menu.Items[app.Mode][i].Text = menu.ShowNextShapeText + "NO"
	} else
	if s == menu.ShowNextShapeText + "NO" {
		    menu.ShowNextShape = true
		menu.Items[app.Mode][i].Text = menu.ShowNextShapeText + "YES"
	}
}
