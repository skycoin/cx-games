/*

In our imagined world for this game, the universe is filled with solid
rock everywhere.

We have a limited grid of possibilities, where we will carve out air space
(Rooms) in each of those cells.  ALMOST each of them.  Some will remain
solid rock, for a bit of variety in how the connected rooms are laid out.

I THINK OF THE Y DIMENSION INCREASING UPWARDS
	SO KEEP THIS IN MIND WITH DIR_ECTIONS AND THE "Rooms" GRID INDEXING 
	
This is how it is by default in OpenGL space, Unity and many modern 3D
apps, so I think it's important to generally keep synchronized with this.

*/

package map

import "app"



var DIR_LEFT  i32 = 0
var DIR_RIGHT i32 = 1
var DIR_DOWN  i32 = 2
var DIR_UP    i32 = 3

var NumCellsAcross i32 = 4 // in both dimensions 
var CellSpan f32 = 2.0 / i32.f32(NumCellsAcross)
var Rooms [4][4]Cell   // FIXME: use constants when we can 
var Carvs []CarvedRoom // used/carved-out locations of the Rooms grid 

type Cell struct {
	Exits     []i32
}

type CarvedRoom struct {
	// insets (from room bounds) 
	/*Top    f32
	Right  f32
	Bottom f32
	Left   f32*/
	
	Pos       app.Vec2
	Exits     []i32
}



func Init () {
	//showActiveStatii()
	setupPossibleExits()
	//showActiveStatii()
	carveOutConnectedRooms()
	printf("aaaaaa: %d \n", Carvs[5].Pos.X)
}


func setupPossibleExits () {
	for iY := 0; iY < NumCellsAcross; iY++ {
	for iX := 0; iX < NumCellsAcross; iX++ {
		var r Cell
		
		if iX > 0 {
			r.Exits = append(
			r.Exits, DIR_LEFT)
		}
		
		if iX < i32.sub(NumCellsAcross, 1) {
			r.Exits = append(
			r.Exits, DIR_RIGHT)
		}
		
		if iY > 0 {
			r.Exits = append(
			r.Exits, DIR_DOWN)
		}
		
		if iY < i32.sub(NumCellsAcross, 1) {
			r.Exits = append(
			r.Exits, DIR_UP)
		}
		
		Rooms[iY][iX] = r
		//printf("setupPossibleExits() len(r.Exits): %d \n", len(r.Exits))
		////var poss []i32 = Rooms[iY][iX].Exits
		////printf("Rooms[iY][iX].Exits: %d \n", len(poss))
	}
	}
}


func getRandomCarvedLoc () (x i32, y i32, r Cell) {
	var rnd i32 = i32.rand(0, len(Carvs))
	i32.print(rnd)
	x = Carvs[rnd].Pos.X
	y = Carvs[rnd].Pos.Y
	r = Rooms[y][x]
}


func carveOutConnectedRooms () {
	var x i32
	var y i32
	var r Cell
		
	var numInactives i32 = i32.rand(1, 5)
	str.print("numInactives: ")
	i32.print(numInactives)
	var n i32 = NumCellsAcross * NumCellsAcross - numInactives
	
	for i := 0; i < n; i++ {
		if /* 1st room */ i == 0 {
			// make anywhere 
			x = i32.rand(0, NumCellsAcross)
			y = i32.rand(0, NumCellsAcross)
			addCarvedRoom(x, y, 0)
		}else{
			x, y, r = getRandomCarvedLoc()
			//printf("carveOutConnectedRooms() len(r.Exits): %d \n", len(r.Exits))
			
			for len(r.Exits) < 1 {
				x, y, r = getRandomCarvedLoc()
			}
			
			// random (exit) id 
			var ri i32 = i32.rand(0, len(r.Exits))
			var e /* exit */ i32 = r.Exits[ri]

			if e == DIR_LEFT {
				promoteExitAt(x,   y, e)
				printf("AFTER promoteExitAt ------num exits: %d \n", len(r.Exits))
				promoteExitAt(x-1, y, DIR_RIGHT)
				addCarvedRoom(x-1, y, DIR_RIGHT)
			}else			
			if e == DIR_RIGHT {
				promoteExitAt(x,   y, e)
				printf("AFTER promoteExitAt ------num exits: %d \n", len(r.Exits))
				promoteExitAt(x+1, y, DIR_LEFT)
				addCarvedRoom(x+1, y, DIR_LEFT)
			}else			
			if e == DIR_DOWN {
				promoteExitAt(x, y,   e)
				printf("AFTER promoteExitAt ------num exits: %d \n", len(r.Exits))
				promoteExitAt(x, y-1, DIR_UP)
				addCarvedRoom(x, y-1, DIR_UP)
			}else			
			if e == DIR_UP {
				promoteExitAt(x, y,   e)
				printf("AFTER promoteExitAt ------num exits: %d \n", len(r.Exits))
				promoteExitAt(x, y+1, DIR_DOWN)
				addCarvedRoom(x, y+1, DIR_DOWN)
			}
		}
	}
}


func addCarvedRoom (x i32, y i32, dir i32) {
	var newLoc CarvedRoom
	newLoc.Pos.X = x
	newLoc.Pos.Y = y
	
	if len(Carvs) != 0 { // no direction to set for 1st room 
		newLoc.Exits = append(
		newLoc.Exits, dir)
	}
	
	Carvs = append(
	Carvs, newLoc)

	printf("addCarvedRoom(%d, %d)   -   len(Carvs): %d \n", x, y, len(Carvs))
}


func promoteExitAt (x i32, y i32, dir i32) {
	var log bool = true//false
	
	if log { 
		str.print("___________________________________________________________")
		printf("promoteExitAt(%d, %d, %s) \n", x, y, getTextForDir(dir))
	}
	
	var r Cell = Rooms[y][x]
	// remove from Exits 
	var n i32 = len(r.Exits)
	for i := i32.sub(n, 1); i >= 0; i = i32.sub(i, 1) {
		if log { str.print(getTextForDir(r.Exits[i]))
		}
		
		if r.Exits[i] == dir {
			if log { str.print("***************************FOUND removable")
			}
			r.Exits = remove(r.Exits, i)
		}
	}
	
	if log { printf("------num exits: %d \n", len(r.Exits))
	}
}


func getInversion (dir i32) (out i32) { // (opposite direction) 
	if dir == DIR_LEFT {
		out = DIR_RIGHT
	}else	
	if dir == DIR_RIGHT {
		out = DIR_LEFT
	}else	
	if dir == DIR_DOWN {
		out = DIR_UP
	}else	
	if dir == DIR_UP {
		out = DIR_DOWN
	}
}


func getTextForDir (dir i32) (out str) {
	if dir ==  DIR_LEFT {
		out = "DIR_LEFT"
	}else	
	if dir ==  DIR_RIGHT {
		out = "DIR_RIGHT"
	}else	
	if dir ==  DIR_DOWN {
		out = "DIR_DOWN"
	}else	
	if dir ==  DIR_UP {
		out = "DIR_UP"
	}
}


func GetNumCarvs () (out i32) {
	out = len(Carvs)
}

func GetGridPos (i i32) (out app.Vec2) {
	out = Carvs[i].Pos
}