package draw

import "gl"

import "app"
import "collision"
import "entity"
import "environs"
import "mesh"


var rngCol          Color3
var NEG_UNIT_SPAN   f32 // negative... 
var CRUST_THICKNESS f32
var currX           f32
var span            f32
var currGreen       f32 // component of terrain fill color 



func Setup () () {
	str.print("draw.Setup()")
	mesh.Setup2()
	
	NEG_UNIT_SPAN = 0.0 - 1.0
	CRUST_THICKNESS = 0.015

	
	// colors 
	var r f32
	var g f32
	var b f32

	r = getRandomForColorChannel()
	g = getRandomForColorChannel()
	b = getRandomForColorChannel()

	rngCol = Color3{ R: r, G: g, B: b }
}


func All (currTime f32) () {
	//str.print("draw.Update()")
	mesh.Draw()

	gl.Begin(gl.QUADS) //POLYGON
	
	//ColorPickerWheel()
	Terrain(currTime)
	Entities()

	gl.End()
	
	/*
	draws polygon from all entity positions 
	gl.Begin(gl.POLYGON)
	simpleVertexSequence(0.0)
	gl.End()
	*/

	/*
	draws loop from all entity positions 
	gl.Begin(gl.LINE_LOOP)
	simpleVertexSequence(0.5)
	gl.End()
	*/

	/*
	gl.Begin(gl.LINES)
	gridLines()
	gl.End()
	*/

	// hero 
	//Circle(entity.Ents[0])
}


func gridLines () () {
	var l f32
	l = f64.f32(collision.ScreenEdgeL)
	
	var r f32
	r = f64.f32(collision.ScreenEdgeR)
	
	numLines := 30
	var unitSpan f32
	unitSpan = f32.mul(r, 2.0)
	unitSpan = f32.div(unitSpan, i32.f32(numLines))
	z := 0.2

	// vertical 
	var fx f32
	fx = l
	for x := 0; x < numLines; x++ {
		gl.Vertex3f(fx, l, z)
		gl.Vertex3f(fx, r, z)
		
		fx = f32.add(fx, unitSpan)
	}
	
	// horizontal 
	var fy f32
	fy = l
	for y := 0; y < numLines; y++ {			
		gl.Vertex3f(l, fy, z)
		gl.Vertex3f(r, fy, z)
		
		fy = f32.add(fy, unitSpan)
	}
}


func Circle (e Entity) () {
	var x f32
	var y f32

	gl.Begin(gl.POLYGON)
	gl.Color3f(1.0, 1.0, 1.0)
	
	var i f32
	for i = 0.0; f32.lt(i, 20.0); i = f32.add(i, 1.0) {
		x = f32.add(e.Pos.X, f32.mul(e.Radius, f32.cos(f32.div(f32.mul(i, app.TAU), 20.0))))
		y = f32.add(e.Pos.Y, f32.mul(e.Radius, f32.sin(f32.div(f32.mul(i, app.TAU), 20.0))))

		gl.Vertex2f(x, y)
	}

	gl.End()
}


func Entities () () {
	for i := 0; i32.lt(i, len(entity.Ents)); i++ {
		var e Entity
		e = entity.Ents[i]
		
		//        ______==________________
		if i32.eq(e.Mode, entity.MODE_DEAD) {
			continue
		}
		
		// colors 
		if e.Type == entity.TYPE_HERO {
			c := 0.4
			gl.Color3f(c, c, c)
		}else
		if e.Type == entity.TYPE_BULLET {
			gl.Color3f(1.0, 1.0, 0.0)
		}else
		if e.Type == entity.TYPE_ROCKET {
			gl.Color3f(1.0, 0.5, 0.0)
		}else
		if e.Type == entity.TYPE_EDITOR_NODE {
			cc := 1.0
			gl.Color3f(cc, cc, cc)
		}


		var lX f32
		lX = f32.sub(e.Pos.X, e.Extents.X)

		var rX f32
		rX = f32.add(e.Pos.X, e.Extents.X)

		var bY f32
		bY = f32.sub(e.Pos.Y, e.Extents.Y)

		var tY f32
		tY = f32.add(e.Pos.Y, e.Extents.Y)
		
		gl.Vertex3f(lX, bY, 0.0)
		gl.Vertex3f(lX, tY, 0.0)
		gl.Vertex3f(rX, tY, 0.0)
		gl.Vertex3f(rX, bY, 0.0)
	}
}


func simpleVertexSequence (colorChanIntensity f32) () {
	gl.Color3f(colorChanIntensity, colorChanIntensity, colorChanIntensity)

	for i := 0; i < len(entity.Ents); i++ {
		var e Entity
		e = entity.Ents[i]

		gl.Vertex2f(e.Pos.X, e.Pos.Y)
	}
}


func ColorPickerWheel () () {
	var NUM_ANGS i32
	NUM_ANGS = 1536 // 3 x 512, 512 needed to show all possible hues between 2 colors 
	// (256 settings per channel, but we alternate between inc/dec 1 chan at a time)

	var ANG_I /* angle increment */ f32
	ANG_I = f32.div(app.TAU, i32.f32(NUM_ANGS))

	var CI /* color increment */ f32
	CI = f32.div(1.0, i32.f32(256))

	var ang f32
	var increase bool
	increase = true

	var red f32
	var green f32
	var blue f32
	red = 1.0

	for i := 0; i < NUM_ANGS; i++ {
		gl.Color3f(red, green, blue)

		gl.Vertex2f(0.0, 0.0)
		gl.Vertex2f(0.0, 0.0)
		gl.Vertex2f(f32.sin(ang), f32.cos(ang))

		ang = f32.add(ang, ANG_I)

		gl.Vertex2f(f32.sin(ang), f32.cos(ang))

		if i >= 1024 {
			if increase {
				red = f32.add(red, CI)
			} else {
				blue = f32.sub(blue, CI)
			}
		} else
		if i >= 512 {
			if increase {
				blue = f32.add(blue, CI)
			} else {
				green = f32.sub(green, CI)
			}
		} else {
			if increase {
				green = f32.add(green, CI)
			} else {
				red = f32.sub(red, CI)
			}
		}

		increase = bool.not(increase)
	}
}


func Terrain (currTime f32) () {
	var num i32
	num = len(environs.Terrain) - 1
	span = f32.div(f64.f32(collision.ScreenEdgeR) * 2.0, i32.f32(num))
	currGreen = 0.2
	currX = f64.f32(collision.ScreenEdgeL)

	for i := 0; i < num; i++ {
		// draw filling (lavender/cyan gradient) 
		feedTerrainQuadToGL(i, false, currTime)

		// draw crust (random color) 
		feedTerrainQuadToGL(i, true, currTime)
		
		currGreen = f32.add(currGreen, 0.01)
		currX     = f32.add(currX,     span)
	}
	
	environs.PopulatedWithEntities = true
}


func feedTerrainQuadToGL(i i32, drawingCrust bool, currTime f32) () {
	var up f32 // upper y edge of quad 
	var lo f32 // lower y edge of quad 
	z := 0.0
	
	// 2 left points of quad 
	up = environs.Terrain[i].Floo
	if drawingCrust {
		lo = environs.Terrain[i].Floo - CRUST_THICKNESS
		gl.Color3f(rngCol.R, rngCol.G, rngCol.B)
	} else {
		lo = NEG_UNIT_SPAN	
		gl.Color3f(0.6, currGreen, 1.0)
	}
	
	
	// left edge 
	gl.Vertex3f(currX, lo, z)
	gl.Vertex3f(currX, up, z)

	
	// 2 right points of quad 
	up =  environs.Terrain[i+1].Floo
	if drawingCrust {
		lo =  environs.Terrain[i+1].Floo - CRUST_THICKNESS
	} else {
		lo = NEG_UNIT_SPAN	
	}


	// right edge 
	gl.Vertex3f(currX + span, up, z)
	gl.Vertex3f(currX + span, lo, z)


	if bool.not(environs.PopulatedWithEntities) {
		if i32.eq(i32.rand(0, 8), 0) {			
			var time f32
			time = i32.f32(i32.rand(0, 20))
			time = f32.mul(time, 0.5)
			time = f32.add(currTime, time)
			
			var pos Vec2
			pos = Vec2{ 
				X: currX + span, 
				Y: f32.add(up, entity.RocketExtents.Y) }
			
			var vel Vec2
			vel = Vec2{ Y: 0.005 }
			
			var ent Entity
			ent = Entity{
				Type: entity.TYPE_ROCKET,
				Pos: pos,
				Vel: vel,
				Mode: entity.MODE_STATIONARY,
				NextMode: entity.MODE_MOVING_STRAIGHT,
				TimeToNextMode: time,
				Extents: entity.RocketExtents }
			
			entity.Add(ent)
		}
	}
}


func getRandomForColorChannel () (out f32) {
	// 257, cuz without the +1 it can never reach value of 1.0 
	var colSpan f32
	colSpan = f32.div(1.0, 257.0)
	
	var f f32
	f = i32.f32(i32.rand(0, 257))
	
	out = f32.mul(f, colSpan)
}
