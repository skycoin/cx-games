package mesh

import "glfw"

import "app"
import "ccInput"
import "collision"



// to keep it simple, we'll sync Colors & Points (rather than indices to a palette) 
type Mesh2D struct {
	Name str
	Colors []Color3 
	Points []Vec2
	TriangleIndices []i32
}

var RawMeshes       []Mesh2D // fully bounded to -1.0 & 1.0 extents 
var SizedMeshes     []Mesh2D // part baked (world size/scale) 
var BakedUIMeshes   []Mesh2D // full baked (world size/scale & pos) for menu/toolbar 
var BakedMeshPicker []Mesh2D // full baked (world size/scale & pos) 
var EditLayers      []Mesh2D // TODO: (just using 1 ATM) a slice (amongst other features) allows multiple vertices at the same position (but with different colors).  allows drastic color changes between adjacent triangle sides 
var CurrLayer   i32
var ColorWheel  i32
var GameOver    i32

var PickedTrianglesNextId i32
var PickedTriangle      []i32

var charMap []str = []str{ "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z" }



func Setup () () {
	str.print("mesh.Setup()")
	
	
	
	// characters 
	for i := 0; i < len(charMap); i++ {
		printf("%s", charMap[i])
	}
	str.print("")



	// toolbar icons 
	
	InitEditVerticesIconMesh()
	InitEditTrianglesIconMesh()

	ColorWheel = len(RawMeshes)
	makeColorPickerWheelResource()

	InitMeshPickerIconMesh()
	InitGenerateFuncIconMesh()
	InitSnapToGridIconMesh()
	InitWipeCanvasIconMesh()
	InitPlayerShipMesh()

	GameOver = len(RawMeshes)
	InitGameOverMesh()

	makeEditorRectResource()	
	
	
	
	// editor 
	
	/////// canvas 
	var m Mesh2D
	m = Mesh2D{ Name: "Editor workspace" }
	EditLayers = append(
	EditLayers, m)
	
	/////// vertex pick/selection triangle (these values only used if PickedTrianglesNextId >= 3) 
	PickedTriangle = append(PickedTriangle, 0)
	PickedTriangle = append(PickedTriangle, 1)
	PickedTriangle = append(PickedTriangle, 2)
}


func makeAndReportOn (m Mesh2D, raw bool) () {
	if raw {
		printf("generating raw mesh:   %d   name: '%s' \n", len(RawMeshes), m.Name)
		RawMeshes = append(
		RawMeshes, m)
	} else {
		printf("generating sized mesh: %d   name: '%s' \n", len(SizedMeshes), m.Name)
		SizedMeshes = append(
		SizedMeshes, m)	
	}
}


/*
func UNUSED_CopyFromEditorToGame () () {
	str.print("mesh.UNUSED_CopyFromEditorToGame ()")
	var m Mesh2D
	m = Mesh2D{ Name: "Copy of UserGenMesh" }
	
	for i := 0; i32.lt(i, len(EditLayers[CurrLayer].Points)); i++ {
		var c Color3
		var p Vec2
		c = EditLayers[CurrLayer].Colors[i]
		p = EditLayers[CurrLayer].Points[i]
		m.Colors = append(
		m.Colors, c)
		m.Points = append(
		m.Points, p)
	}

	for j := 0; i32.lt(j, len(EditLayers[CurrLayer].TriangleIndices)); j++ {
		var id i32
		id = EditLayers[CurrLayer].TriangleIndices[j]
		m.TriangleIndices = append(
		m.TriangleIndices, id)
	}
		
	makeAndReportOn(m, false)
}
*/


func GenerateMeshInitFunc (s str) () {
	printf("___________________________________________________________ \n")
	printf("Init%sMesh() \n\n", s)
	printf("func Init%sMesh () () { \n", s)
	printf("    var m Mesh2D \n")
	printf("    m = Mesh2D{ Name: Raw } \n")
	printf(" \n")
	
	printf("    var c Color3 \n")
	printf("    var v Vec2 \n\n")
	
	for li := 0; i32.lt(li, len(EditLayers)); li++ {
		for i := 0; i32.lt(i, len(EditLayers[li].Colors)); i++ {
			printf("    c = Color3{ R: %f, G: %f , B: %f } \n", 
				EditLayers[li].Colors[i].R,
				EditLayers[li].Colors[i].G,
				EditLayers[li].Colors[i].B)
			printf("    m.Colors = append( \n")
			printf("    m.Colors, c) \n")
		}

		printf(" \n")
		
		for i := 0; i32.lt(i, len(EditLayers[li].Points)); i++ {
			printf("    v = Vec2{ X: %f , Y: %f } \n", 
				EditLayers[li].Points[i].X,
				EditLayers[li].Points[i].Y)
			printf("    m.Points = append( \n")
			printf("    m.Points, v) \n")
		}

		printf(" \n")
		
		for j := 0; i32.lt(j, len(EditLayers[li].TriangleIndices)); j++ {
			printf("    m.TriangleIndices = append( \n")
			printf("    m.TriangleIndices, %d) \n", EditLayers[li].TriangleIndices[j])
		}
	}
	
	printf("\n    makeAndReportOn(m, true) \n")
	printf("} \n")
}


func BakeMeshPickerButtonGrid () () {
	str.print("BakeMeshPickerButtonGrid ()")
	
	
	var extent f32 // from center of icon background 
	extent = f32.div(ccInput.ButtonSpan, 2.0)
	
	var x f32	
	var y f32

	/*
	if vertical {
		if minimumEdge {
			x = f64.f32(collision.ScreenEdgeL) + extent
		} else {
			x = f64.f32(collision.ScreenEdgeR) - extent
		}
		
		y = f32.div(longSpan, 2.0)
		y = f32.sub(y, extent)
	} else { // horizontal 
		x = f32.div(longSpan, 2.0)
		x = -x
		x = f32.add(x, extent)

		if minimumEdge {
			y = -1.0 + extent
		} else {
			y = 1.0 - extent
		}
	}

	var pos Vec2
	var ext Vec2
	pos = Vec2{ X: x,      Y: y      }
	ext = Vec2{ X: extent, Y: extent }

	for i := 0; i32.lt(i, numItems); i++ {
		ccInput.Menus[menu].Items[i].Pos = pos
		ccInput.Menus[menu].Items[i].Extents = ext
		bakeInstanceFromRaw(pos, ext, len(RawMeshes)-1) // rect background 
		
		if i < len(RawMeshes) {
			bakeInstanceFromRaw(pos, ext, i)
			ccInput.Menus[menu].Items[i].RawMeshForIcon = i
		}
			
		if vertical {
			pos.Y = f32.sub(pos.Y, span)
		} else { // horizontal 
			pos.X = f32.add(pos.X, span)
		}
	}
	*/
}


func BakeButtonArray (menu i32, minimumEdge bool, vertical bool) () {
	str.print("BakeButtonArray ()")
	
	var numItems i32
	numItems = len(ccInput.Menus[menu].Items)
	
	var extent f32 // from center of icon background 
	extent = f32.div(ccInput.ButtonSpan, 2.0)
	
	var longSpan f32 // span across the longest dimension 
	longSpan = f32.mul(ccInput.ButtonSpan, i32.f32(numItems))

	var x f32	
	var y f32

	if vertical {
		if minimumEdge {
			x = f64.f32(collision.ScreenEdgeL) + extent
		} else {
			x = f64.f32(collision.ScreenEdgeR) - extent
		}
		
		y = f32.div(longSpan, 2.0)
		y = f32.sub(y, extent)
	} else { // horizontal 
		x = f32.div(longSpan, 2.0)
		x = -x
		x = f32.add(x, extent)

		if minimumEdge {
			y = -1.0 + extent
		} else {
			y = 1.0 - extent
		}
	}

	var pos Vec2
	var ext Vec2
	pos = Vec2{ X: x,      Y: y      }
	ext = Vec2{ X: extent, Y: extent }

	for i := 0; i32.lt(i, numItems); i++ {
		ccInput.Menus[menu].Items[i].Pos = pos
		ccInput.Menus[menu].Items[i].Extents = ext
		bakeInstanceFromRaw(pos, ext, len(RawMeshes)-1) // rect background 
		
		if i < len(RawMeshes) {
			bakeInstanceFromRaw(pos, ext, i)
			ccInput.Menus[menu].Items[i].RawMeshForIcon = i
		}
			
		if vertical {
			pos.Y = f32.sub(pos.Y, ccInput.ButtonSpan)
		} else { // horizontal 
			pos.X = f32.add(pos.X, ccInput.ButtonSpan)
		}
	}
}


func bakeInstanceFromRaw (pos Vec2, extents Vec2, rawId i32) () {
	//str.print("bakeInstanceFromRaw () (from editor)")
			
	var m Mesh2D
	m = Mesh2D{ Name: "bakedInstanceFromRaw" }

	// bake colors/verts 
	for k := 0; i32.lt(k, len(RawMeshes[rawId].Points)); k++ {
		var c Color3
		var p Vec2
		c = RawMeshes[rawId].Colors[k]
		p = RawMeshes[rawId].Points[k]
		
		// scale 
		p.X = f32.mul(p.X, extents.X)
		p.Y = f32.mul(p.Y, extents.Y)
		
		// position 
		p.X = f32.add(pos.X, p.X)
		p.Y = f32.add(pos.Y, p.Y)
		
		m.Colors = append(
		m.Colors, c)
		m.Points = append(
		m.Points, p)
	}

	// bake triangles 
	for j := 0; i32.lt(j, len(RawMeshes[rawId].TriangleIndices)); j++ {
		var id i32
		id = RawMeshes[rawId].TriangleIndices[j]
		m.TriangleIndices = append(
		m.TriangleIndices, id)
	}

	BakedUIMeshes = append(
	BakedUIMeshes, m)
}


func makeEditorRectResource () () {
	var m Mesh2D
	m = Mesh2D{ Name: "makeEditorRectResource" }
	
	var top f32
	var right f32
	var bottom f32
	var left f32
	
	top = 1.0
	right = 1.0
	bottom = -1.0
	left = -1.0
	
	// colors 
	var col Color3
	col = Color3{ R: 1.0, G: 0.2, B: 0.2 }

	var colSpan f32
	colSpan = 0.2	

	col.R = f32.sub(col.R, colSpan)
	m.Colors = append(m.Colors, col)
	
	col.R = f32.sub(col.R, colSpan)
	m.Colors = append(m.Colors, col)
	
	col.R = f32.sub(col.R, colSpan)
	m.Colors = append(m.Colors, col)
	
	col.R = f32.sub(col.R, colSpan)
	m.Colors = append(m.Colors, col)

		
	// positions 
	var v Vec2
	v = Vec2{ X: 0.0, Y: 0.0 }
	
	// start at... 
	v.X = left
	v.Y = top
	// ...then go clockwise 
	m.Points = append(m.Points, v)
	v.X = right
	v.Y = top
	m.Points = append(m.Points, v)
	v.X = right
	v.Y = bottom
	m.Points = append(m.Points, v)
	v.X = left
	v.Y = bottom
	m.Points = append(m.Points, v)

		
	// triangles 
	m.TriangleIndices = append(m.TriangleIndices, 0)
	m.TriangleIndices = append(m.TriangleIndices, 1)
	m.TriangleIndices = append(m.TriangleIndices, 2)

	m.TriangleIndices = append(m.TriangleIndices, 2)
	m.TriangleIndices = append(m.TriangleIndices, 3)
	m.TriangleIndices = append(m.TriangleIndices, 0)
	
	makeAndReportOn(m, true)
}


// NON-editor tri 
/*
func MakeNewTriangle (a Vec2, b Vec2, c Vec2) () {
	////////////////// UNTESTED \\\\\\\\\\\\\\\\\\\\\
	str.print("mesh.MakeNewTriangle()   (NON-editor)")
	
	var m Mesh2D
	m = Mesh2D{ Name: "NON-editor triangle" }
	
	var col Color3
	col = Color3{ R: 1.0, G: 0.5, B: 0.9 }
	
	m.Colors = append(m.Colors, col)
	col.B = 0.6
	m.Colors = append(m.Colors, col)
	col.B = 0.2
	m.Colors = append(m.Colors, col)
	
	m.Points = append(m.Points, a)
	m.Points = append(m.Points, b)
	m.Points = append(m.Points, c)
	
	var tii i32 // tri indices index 
	tii = len(SizedMeshes[0].TriangleIndices)
	
	SizedMeshes[0].TriangleIndices = append(SizedMeshes[0].TriangleIndices, tii)
	tii = i32.add(tii, 1)
	SizedMeshes[0].TriangleIndices = append(SizedMeshes[0].TriangleIndices, tii)
	tii = i32.add(tii, 1)
	SizedMeshes[0].TriangleIndices = append(SizedMeshes[0].TriangleIndices, tii)
	
	makeAndReportOn(m, false)
}
*/

func MakeNewEditorTriangle () () { // just tri indices to existing global (ATM) EditorMesh 
	str.print("mesh.MakeNewEditorTriangle()")
	
	
	// feedback BEFORE 
	printf("PickedTriangle[0]: %d \n", PickedTriangle[0])
	printf("PickedTriangle[1]: %d \n", PickedTriangle[1])
	printf("PickedTriangle[2]: %d \n", PickedTriangle[2])
	
	var numIds i32
	numIds = len(EditLayers[CurrLayer].TriangleIndices)
	printf("numIds BEFORE: %d \n", numIds)
	
	var numErrs i32 // erroneous leftover indices (indicating not a multiple of 3) 
	var numTris i32
	numTris = i32.div(numIds, 3)
	numErrs = i32.mod(numIds, 3)
	printf("numTris BEFORE: %d \n", numTris)
	
	
	// MEAT of func 
	EditLayers[CurrLayer].TriangleIndices = append(
	EditLayers[CurrLayer].TriangleIndices, PickedTriangle[0])
	EditLayers[CurrLayer].TriangleIndices = append(
	EditLayers[CurrLayer].TriangleIndices, PickedTriangle[1])
	EditLayers[CurrLayer].TriangleIndices = append(
	EditLayers[CurrLayer].TriangleIndices, PickedTriangle[2])


	// feedback AFTER 
	numIds  = len(EditLayers[CurrLayer].TriangleIndices)
	numTris = i32.div(numIds, 3)
	numErrs = i32.mod(numIds, 3) // num/how-many erroneous/leftover 
	printf("numIds AFTER: %d \n", numIds)
	printf("numTris AFTER: %d \n", numTris)
	
	if i32.uneq(numErrs, 0) {
		printf("********* ERROR! numErrs: %d \n", numErrs)
		printf("********* ERROR! numErrs: %d \n", numErrs)
		printf("********* ERROR! numErrs: %d \n", numErrs)
	}

	printf("EditLayers[CurrLayer].Points len: %d \n", len(EditLayers[0].Points))
}


func RemoveVertexNode (layerId i32, ir i32 /* id to remove */) () {
	if app.Mode != app.APPMODE_EDITOR {		
		return
	}
	
	printf("mesh.RemoveVertexNode(%d) \n", ir)

	var m Mesh2D
	m = Mesh2D{ Name: EditLayers[CurrLayer].Name }
	
	for i := 0; i32.lt(i, len(EditLayers[CurrLayer].Points)); i++ {
		if i32.uneq(i, ir) {
			m.Colors = append(
			m.Colors, EditLayers[CurrLayer].Colors[i])
			m.Points = append(
			m.Points, EditLayers[CurrLayer].Points[i])
		}
	}

	// remove tris that point to "ir" 
	// (handle 3 verts at a time (+=3 increment), "j" being the latest) 
	for j := 2; i32.lt(j, len(EditLayers[CurrLayer].TriangleIndices)); j = i32.add(j, 3) {
		var j0 i32
		var j1 i32
		var j2 i32
		
		j0 = i32.sub(j, 2)
		j1 = i32.sub(j, 1)
		j2 = j
		
		j0 = EditLayers[CurrLayer].TriangleIndices[j0]
		j1 = EditLayers[CurrLayer].TriangleIndices[j1]
		j2 = EditLayers[CurrLayer].TriangleIndices[j2]
		
		// if tri will remain, copy it 
		if i32.uneq(j0, ir) && 
			i32.uneq(j1, ir) && 
			i32.uneq(j2, ir) {

			m.TriangleIndices = append(
			m.TriangleIndices, j0)
			m.TriangleIndices = append(
			m.TriangleIndices, j1)
			m.TriangleIndices = append(
			m.TriangleIndices, j2)
			
			str.print("SAVING TRIANGLE")
		} else {
			str.print("DELETED TRIANGLE")
		}		
	}

	// - vert ids that are > "ir" 
	for l := 0; i32.lt(l, len(EditLayers[CurrLayer].TriangleIndices)); l++ {
		m.TriangleIndices[l] = getValidId(layerId, ir, l)
	}

	/*
	var num i32
	num = i32.sub(len(m.Points), 1)
	printf("---num: %d \n", num)
	printf("---len(m.Colors): %d \n", len(m.Colors))
	printf("---len(m.Points): %d \n", len(m.Points))
	printf("---m.Points[num].X: %f \n", m.Points[num].X)
	printf("---m.Points[num].Y: %f \n", m.Points[num].Y)
	printf("---len(m.TriangleIndices): %d \n", len(m.TriangleIndices))
	
	num = i32.sub(len(EditLayers[CurrLayer].Points), 1)
	printf("---num: %d \n", num)
	printf("---len(EditLayers[CurrLayer].Colors): %d \n", len(EditLayers[CurrLayer].Colors))
	printf("---len(EditLayers[CurrLayer].Points): %d \n", len(EditLayers[CurrLayer].Points))
	printf("---EditLayers[CurrLayer].Points[num].X: %f \n", EditLayers[CurrLayer].Points[num].X)
	printf("---EditLayers[CurrLayer].Points[num].Y: %f \n", EditLayers[CurrLayer].Points[num].Y)
	printf("---len(EditLayers[CurrLayer].TriangleIndices): %d \n", len(EditLayers[CurrLayer].TriangleIndices))
	*/
	
	EditLayers[CurrLayer] = m
}


func getValidId (layer i32, trashVert i32, currVert i32) (id i32) {
	id = EditLayers[layer].TriangleIndices[currVert]

	// decrease vertex id by 1, if it's after removed index 
	if i32.lt(trashVert, id) {
		id = i32.sub(id, 1)
	}
}
