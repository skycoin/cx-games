package mesh

import "glfw"

import "app"
import "ccInput"
import "collision"




type Mesh2D struct {
	Name str
	Colors []Color3 // to keep it simple, we'll sync this with Points (rather than indices to a palette) 
	Points []Vec2
	TriangleIndices []i32
}

var Meshes []Mesh2D
var RawEditorMeshes []Mesh2D
var BakedEditorMeshes []Mesh2D
var PickedTrianglesNextId i32
var PickedTriangle []i32



func Setup2 () () { // FIXME: rename when we can call _func_name_ within _same_func_name_ 
	str.print("mesh.Setup2()")
	
	// editor 
	
	//		mesh 0, blank workspace for user editing 
	var m Mesh2D
	m = Mesh2D{ Name: "Editor workspace" }
	makeAndReportOn(m, true)
	
	makeColorPickerWheelResource()
	makeEditorRectResource()
	InitBMesh()
	
	// 		vertex pick/selection triangle (these values only used if PickedTrianglesNextId >= 3) 
	PickedTriangle = append(PickedTriangle, 0)
	PickedTriangle = append(PickedTriangle, 1)
	PickedTriangle = append(PickedTriangle, 2)
}


func makeAndReportOn (m Mesh2D, editor bool) () {
	if editor {
		printf("generating editor mesh: %d   name: '%s' \n", len(RawEditorMeshes), m.Name)
		RawEditorMeshes = append(RawEditorMeshes, m)
	} else {
		printf("generating game mesh:   %d   name: '%s' \n", len(Meshes),       m.Name)
		Meshes       = append(Meshes, m)	
	}
}


func UNUSEDCopyFromEditorToGame () () {
	str.print("mesh.CopyFromEditorToGame ()")
	var m Mesh2D
	m = Mesh2D{ Name: "Copy of UserGenMesh" }
	
	for i := 0; i32.lt(i, len(RawEditorMeshes[0].Points)); i++ {
		var c Color3
		var p Vec2
		c = RawEditorMeshes[0].Colors[i]
		p = RawEditorMeshes[0].Points[i]
		m.Colors = append(
		m.Colors, c)
		m.Points = append(
		m.Points, p)
	}

	for j := 0; i32.lt(j, len(RawEditorMeshes[0].TriangleIndices)); j++ {
		var id i32
		id = RawEditorMeshes[0].TriangleIndices[j]
		m.TriangleIndices = append(
		m.TriangleIndices, id)
	}
		
	makeAndReportOn(m, false)
}


func GenerateMeshInitFunc () () {
	printf("func InitMesh () () { \n")
	printf("    var m Mesh2D \n")
	printf("    m = Mesh2D{ Name: 'InitMesh' } \n")
	printf(" \n")
	
	printf("    var c Color3 \n")
	printf("    var v Vec2 \n\n")
	
	for i := 0; i32.lt(i, len(RawEditorMeshes[0].Colors)); i++ {
		printf("    c = Color3{ R: %f, G: %f , B: %f } \n", 
			RawEditorMeshes[0].Colors[i].R,
			RawEditorMeshes[0].Colors[i].G,
			RawEditorMeshes[0].Colors[i].B)
		printf("    m.Colors = append( \n")
		printf("    m.Colors, c) \n")
	}

	printf(" \n")
	
	for i := 0; i32.lt(i, len(RawEditorMeshes[0].Points)); i++ {
		printf("    v = Vec2{ X: %f , Y: %f } \n", 
			RawEditorMeshes[0].Points[i].X,
			RawEditorMeshes[0].Points[i].Y)
		printf("    m.Points = append( \n")
		printf("    m.Points, v) \n")
	}

	printf(" \n")
	
	for j := 0; i32.lt(j, len(RawEditorMeshes[0].TriangleIndices)); j++ {
		printf("    m.TriangleIndices = append( \n")
		printf("    m.TriangleIndices, %d) \n", RawEditorMeshes[0].TriangleIndices[j])
	}
	
	printf("\n    makeAndReportOn(m, true) \n")
	printf("} \n")
}


func makeColorPickerWheelResource () () {
	var NUM_ANGS i32
	NUM_ANGS = 1536 // 3 x 512, 512 needed to show all possible hues between 2 colors 
	// (256 settings per channel, but we alternate between inc/dec 1 chan at a time)

	var ANG_I /* angle increment */ f32
	ANG_I = f32.div(app.TAU, i32.f32(NUM_ANGS))

	var CI /* color increment */ f32
	CI = f32.div(1.0, i32.f32(256))

	var ang f32
	var increase bool
	increase = true

	var red f32
	var green f32
	var blue f32
	red = 1.0

	var m Mesh2D
	m = Mesh2D{ Name: "Color Picker Wheel" }
	
	var cti     i32 // current triangle index 
	var currCol Color3
	var center  Vec2
	center = Vec2{ X: 0.0, Y: 0.0 }
	for i := 0; i < NUM_ANGS; i++ {
		currCol = Color3{ R: red, G: green, B: blue }
		
		m.Colors = append(m.Colors, currCol)
		m.Colors = append(m.Colors, currCol)
		m.Colors = append(m.Colors, currCol)

		var leftFromCenter  Vec2
		var rightFromCenter Vec2
		leftFromCenter  = Vec2{ X: f32.sin(ang), Y: f32.cos(ang) }
		ang = f32.add(ang, ANG_I)
		rightFromCenter = Vec2{ X: f32.sin(ang), Y: f32.cos(ang) }
		
		m.Points = append(m.Points, center)
		m.Points = append(m.Points, leftFromCenter)
		m.Points = append(m.Points, rightFromCenter)

		m.TriangleIndices = append(m.TriangleIndices, cti)
		cti = i32.add(cti, 1)
		m.TriangleIndices = append(m.TriangleIndices, cti)
		cti = i32.add(cti, 1)
		m.TriangleIndices = append(m.TriangleIndices, cti)
		cti = i32.add(cti, 1)

		if i >= 1024 {
			if increase {
				red = f32.add(red, CI)
			} else {
				blue = f32.sub(blue, CI)
			}
		} else
		if i >= 512 {
			if increase {
				blue = f32.add(blue, CI)
			} else {
				green = f32.sub(green, CI)
			}
		} else {
			if increase {
				green = f32.add(green, CI)
			} else {
				red = f32.sub(red, CI)
			}
		}

		increase = bool.not(increase)
	}
	
	makeAndReportOn(m, true)
}


func MakeButtonArray (leftAnchored bool) () {
	str.print("MakeButtonArray ()")
	
	var span f32 // edge to edge size across icon background 
	span = 0.2
	
	var extent f32 // from center of icon background 
	extent = f32.div(span, 2.0)
	
	var /* tool... */ barHei f32
	barHei = f32.mul(span, i32.f32(len(ccInput.Menu)))

	var x f32	
	if leftAnchored {
		x = f64.f32(collision.ScreenEdgeL) + extent
	} else { // right anchored 
		x = f64.f32(collision.ScreenEdgeR) - extent
	}
	
	var y f32
	y = f32.div(barHei, 2.0)
	y = f32.sub(y, extent)

	var pos Vec2
	var ext Vec2
	pos = Vec2{ X: x,      Y: y      }
	ext = Vec2{ X: extent, Y: extent }

	for i := 0; i32.lt(i, len(ccInput.Menu)); i++ {
		ccInput.Menu[i].Pos = pos
		ccInput.Menu[i].Extents = ext
		bakeInstanceFromRaw(pos, ext, 2) // rect background 
		
		var rawId i32
		rawId = i + 3
		
		if rawId < len(RawEditorMeshes) {
			bakeInstanceFromRaw(pos, ext, rawId)
			ccInput.Menu[i].MeshForIcon = rawId
		}
			
		pos.Y = f32.sub(pos.Y, span)
	}
}


func bakeInstanceFromRaw (pos Vec2, extents Vec2, rawId i32) () {
	str.print("bakeInstanceFromRaw ()   copying, scaling & positioning (from editor raw meshes)")
			
	var m Mesh2D
	m = Mesh2D{ Name: "bakedInstanceFromRaw" }

	// bake colors/verts 
	for k := 0; i32.lt(k, len(RawEditorMeshes[rawId].Points)); k++ {
		var c Color3
		var p Vec2
		c = RawEditorMeshes[rawId].Colors[k]
		p = RawEditorMeshes[rawId].Points[k]
		
		// scale 
		p.X = f32.mul(p.X, extents.X)
		p.Y = f32.mul(p.Y, extents.Y)
		
		// position 
		p.X = f32.add(pos.X, p.X)
		p.Y = f32.add(pos.Y, p.Y)
		
		m.Colors = append(
		m.Colors, c)
		m.Points = append(
		m.Points, p)
	}

	// bake triangles 
	for j := 0; i32.lt(j, len(RawEditorMeshes[rawId].TriangleIndices)); j++ {
		var id i32
		id = RawEditorMeshes[rawId].TriangleIndices[j]
		m.TriangleIndices = append(
		m.TriangleIndices, id)
	}

	BakedEditorMeshes = append(
	BakedEditorMeshes, m)
}


func makeEditorRectResource () () {
	var m Mesh2D
	m = Mesh2D{ Name: "makeEditorRectResource" }
	
	var top f32
	var right f32
	var bottom f32
	var left f32
	
	top = 1.0
	right = 1.0
	bottom = -1.0
	left = -1.0
	
	// colors 
	var col Color3
	col = Color3{ R: 1.0, G: 0.2, B: 0.2 }

	var colSpan f32
	colSpan = 0.2	

	col.R = f32.sub(col.R, colSpan)
	m.Colors = append(m.Colors, col)
	
	col.R = f32.sub(col.R, colSpan)
	m.Colors = append(m.Colors, col)
	
	col.R = f32.sub(col.R, colSpan)
	m.Colors = append(m.Colors, col)
	
	col.R = f32.sub(col.R, colSpan)
	m.Colors = append(m.Colors, col)

		
	// positions 
	var v Vec2
	v = Vec2{ X: 0.0, Y: 0.0 }
	
	// start at... 
	v.X = left
	v.Y = top
	// ...then go clockwise 
	m.Points = append(m.Points, v)
	v.X = right
	v.Y = top
	m.Points = append(m.Points, v)
	v.X = right
	v.Y = bottom
	m.Points = append(m.Points, v)
	v.X = left
	v.Y = bottom
	m.Points = append(m.Points, v)

		
	// triangles 
	m.TriangleIndices = append(m.TriangleIndices, 0)
	m.TriangleIndices = append(m.TriangleIndices, 1)
	m.TriangleIndices = append(m.TriangleIndices, 2)

	m.TriangleIndices = append(m.TriangleIndices, 2)
	m.TriangleIndices = append(m.TriangleIndices, 3)
	m.TriangleIndices = append(m.TriangleIndices, 0)
	
	makeAndReportOn(m, true)
}


func MakeNewTriangle /* NON-editor */ (a Vec2, b Vec2, c Vec2) () {
	////////////////// UNTESTED \\\\\\\\\\\\\\\\\\\\\
	str.print("mesh.MakeNewTriangle()   (NON-editor)")
	
	var m Mesh2D
	m = Mesh2D{ Name: "NON-editor triangle" }
	
	var col Color3
	col = Color3{ R: 1.0, G: 0.5, B: 0.9 }
	
	m.Colors = append(m.Colors, col)
	col.B = 0.6
	m.Colors = append(m.Colors, col)
	col.B = 0.2
	m.Colors = append(m.Colors, col)
	
	m.Points = append(m.Points, a)
	m.Points = append(m.Points, b)
	m.Points = append(m.Points, c)
	
	var tii /* tri indices index */ i32
	tii = len(Meshes[0].TriangleIndices)
	
	Meshes[0].TriangleIndices = append(Meshes[0].TriangleIndices, tii)
	tii = i32.add(tii, 1)
	Meshes[0].TriangleIndices = append(Meshes[0].TriangleIndices, tii)
	tii = i32.add(tii, 1)
	Meshes[0].TriangleIndices = append(Meshes[0].TriangleIndices, tii)
	
	makeAndReportOn(m, false)
}


func MakeNewEditorTriangle () () { // just tri indices to existing global (ATM) EditorMesh 
	str.print("mesh.MakeNewEditorTriangle()")
	
	
	// feedback BEFORE 
	printf("PickedTriangle[0]: %d \n", PickedTriangle[0])
	printf("PickedTriangle[1]: %d \n", PickedTriangle[1])
	printf("PickedTriangle[2]: %d \n", PickedTriangle[2])
	
	var numIds i32
	numIds = len(RawEditorMeshes[0].TriangleIndices)
	printf("numIds BEFORE: %d \n", numIds)
	
	var numErrs i32 // erroneous leftover indices (indicating not a multiple of 3) 
	var numTris i32
	numTris = i32.div(numIds, 3)
	numErrs = i32.mod(numIds, 3)
	printf("numTris BEFORE: %d \n", numTris)
	
	
	// MEAT of func 
	RawEditorMeshes[0].TriangleIndices = append(RawEditorMeshes[0].TriangleIndices, PickedTriangle[0])
	RawEditorMeshes[0].TriangleIndices = append(RawEditorMeshes[0].TriangleIndices, PickedTriangle[1])
	RawEditorMeshes[0].TriangleIndices = append(RawEditorMeshes[0].TriangleIndices, PickedTriangle[2])


	// feedback AFTER 
	numIds  = len(RawEditorMeshes[0].TriangleIndices)
	numTris = i32.div(numIds, 3)
	numErrs = i32.mod(numIds, 3)
	printf("numIds AFTER: %d \n", numIds)
	printf("numTris AFTER: %d \n", numTris)
	
	if i32.uneq(numErrs, 0) {
		printf("********* ERROR! numErrs: %d \n", numErrs)
		printf("********* ERROR! numErrs: %d \n", numErrs)
		printf("********* ERROR! numErrs: %d \n", numErrs)
	}

	printf("RawEditorMeshes[0].Points len: %d \n", len(RawEditorMeshes[0].Points))
}


func RemoveVertexNode (/* id to remove */ ir i32) () {
	if app.Mode != app.MODE_EDITOR {		
		return
	}
	
	printf("mesh.RemoveVertexNode(%d) \n", ir)

	var m Mesh2D
	m = Mesh2D{ Name: RawEditorMeshes[0].Name }
	
	for i := 0; i32.lt(i, len(RawEditorMeshes[0].Points)); i++ {
		if i32.uneq(i, ir) {
			m.Colors = append(
			m.Colors, RawEditorMeshes[0].Colors[i])
			m.Points = append(
			m.Points, RawEditorMeshes[0].Points[i])
		}
	}

	// remove tris that point to "ir" 
	// (handle 3 at a time (+=3 increment), "j" being the last) 
	for j := 2; i32.lt(j, len(RawEditorMeshes[0].TriangleIndices)); j = i32.add(j, 3) {
		var j0 i32
		var j1 i32
		var j2 i32
		
		j0 = i32.sub(j, 2)
		j1 = i32.sub(j, 1)
		j2 = j
		
		if i32.uneq(j0, ir) &&
			i32.uneq(j1, ir) &&
			i32.uneq(j2, ir) {
			
			m.TriangleIndices = append(
			m.TriangleIndices, RawEditorMeshes[0].TriangleIndices[j0])
			m.TriangleIndices = append(
			m.TriangleIndices, RawEditorMeshes[0].TriangleIndices[j1])
			m.TriangleIndices = append(
			m.TriangleIndices, RawEditorMeshes[0].TriangleIndices[j2])
		}
	}

	// adjust vert ids (down) that are above "ir" 
	for j := 0; i32.lt(j, len(RawEditorMeshes[0].TriangleIndices)); j++ {
		m.TriangleIndices[j] = getMaybeAdjustedId(ir, j)
	}

	/*
	var num i32
	num = i32.sub(len(m.Points), 1)
	printf("---num: %d \n", num)
	printf("---len(m.Colors): %d \n", len(m.Colors))
	printf("---len(m.Points): %d \n", len(m.Points))
	printf("---m.Points[num].X: %f \n", m.Points[num].X)
	printf("---m.Points[num].Y: %f \n", m.Points[num].Y)
	printf("---len(m.TriangleIndices): %d \n", len(m.TriangleIndices))
	
	num = i32.sub(len(RawEditorMeshes[0].Points), 1)
	printf("---num: %d \n", num)
	printf("---len(RawEditorMeshes[0].Colors): %d \n", len(RawEditorMeshes[0].Colors))
	printf("---len(RawEditorMeshes[0].Points): %d \n", len(RawEditorMeshes[0].Points))
	printf("---RawEditorMeshes[0].Points[num].X: %f \n", RawEditorMeshes[0].Points[num].X)
	printf("---RawEditorMeshes[0].Points[num].Y: %f \n", RawEditorMeshes[0].Points[num].Y)
	printf("---len(RawEditorMeshes[0].TriangleIndices): %d \n", len(RawEditorMeshes[0].TriangleIndices))
	*/
	
	RawEditorMeshes[0] = m

}


func getMaybeAdjustedId (removeId i32, j i32) (jOut i32) {
	jOut = RawEditorMeshes[0].TriangleIndices[j]

	// decrease vertex id by 1, if it's after removed index 
	if i32.gt(jOut, removeId) { // should never == removeId 
		jOut = i32.sub(jOut, 1)
	}
}


func InitBMesh () () {
    var m Mesh2D
    m = Mesh2D{ Name: "BMesh" }

    var c Color3
    var v Vec2

    c = Color3{ R: 0.5000000, G: 0.5000000 , B: 0.5000000 }
    m.Colors = append(
    m.Colors, c)

    c = Color3{ R: 0.5000000, G: 0.5000000 , B: 0.5000000 }
    m.Colors = append(
    m.Colors, c)

    c = Color3{ R: 0.5000000, G: 0.5000000 , B: 0.5000000 }
    m.Colors = append(
    m.Colors, c)

    c = Color3{ R: 0.5000000, G: 0.5000000 , B: 0.5000000 }
    m.Colors = append(
    m.Colors, c)

    c = Color3{ R: 0.5000000, G: 0.5000000 , B: 0.5000000 }
    m.Colors = append(
    m.Colors, c)

    c = Color3{ R: 0.5000000, G: 0.5000000 , B: 0.5000000 }
    m.Colors = append(
    m.Colors, c)

    c = Color3{ R: 0.5000000, G: 0.5000000 , B: 0.5000000 }
    m.Colors = append(
    m.Colors, c)

    c = Color3{ R: 0.5000000, G: 0.5000000 , B: 0.5000000 }
    m.Colors = append(
    m.Colors, c)

    c = Color3{ R: 0.5000000, G: 0.5000000 , B: 0.5000000 }
    m.Colors = append(
    m.Colors, c)

    c = Color3{ R: 0.5000000, G: 0.5000000 , B: 0.5000000 }
    m.Colors = append(
    m.Colors, c)

    c = Color3{ R: 0.5000000, G: 0.5000000 , B: 0.5000000 }
    m.Colors = append(
    m.Colors, c)

    c = Color3{ R: 0.5000000, G: 0.5000000 , B: 0.5000000 }
    m.Colors = append(
    m.Colors, c)

    c = Color3{ R: 0.5000000, G: 0.5000000 , B: 0.5000000 }
    m.Colors = append(
    m.Colors, c)

    c = Color3{ R: 0.5000000, G: 0.5000000 , B: 0.5000000 }
    m.Colors = append(
    m.Colors, c)

    c = Color3{ R: 0.5000000, G: 0.5000000 , B: 0.5000000 }
    m.Colors = append(
    m.Colors, c)

    c = Color3{ R: 0.5000000, G: 0.5000000 , B: 0.5000000 }
    m.Colors = append(
    m.Colors, c)

    c = Color3{ R: 0.5000000, G: 0.5000000 , B: 0.5000000 }
    m.Colors = append(
    m.Colors, c)

    c = Color3{ R: 0.5000000, G: 0.5000000 , B: 0.5000000 }
    m.Colors = append(
    m.Colors, c)

    c = Color3{ R: 0.5000000, G: 0.5000000 , B: 0.5000000 }
    m.Colors = append(
    m.Colors, c)

    c = Color3{ R: 0.5000000, G: 0.5000000 , B: 0.5000000 }
    m.Colors = append(
    m.Colors, c)

    c = Color3{ R: 0.5000000, G: 0.5000000 , B: 0.5000000 }
    m.Colors = append(
    m.Colors, c)

    v = Vec2{ X: -0.9333333 , Y: 0.3638889 }
    m.Points = append(
    m.Points, v)

    v = Vec2{ X: -0.6750000 , Y: 0.4055555 }
    m.Points = append(
    m.Points, v)

    v = Vec2{ X: -0.3888888 , Y: 0.6472222 }
    m.Points = append(
    m.Points, v)

    v = Vec2{ X: -0.2194445 , Y: 0.9555556 }
    m.Points = append(
    m.Points, v)

    v = Vec2{ X: -0.0611111 , Y: 0.8194444 }
    m.Points = append(
    m.Points, v)

    v = Vec2{ X: 0.2416667 , Y: 0.9416667 }
    m.Points = append(
    m.Points, v)

    v = Vec2{ X: 0.6666666 , Y: 0.9388889 }
    m.Points = append(
    m.Points, v)

    v = Vec2{ X: 0.8805555 , Y: 0.6666666 }
    m.Points = append(
    m.Points, v)

    v = Vec2{ X: 0.9499999 , Y: 0.2472222 }
    m.Points = append(
    m.Points, v)

    v = Vec2{ X: 0.7166668 , Y: -0.0027778 }
    m.Points = append(
    m.Points, v)

    v = Vec2{ X: 0.3750001 , Y: -0.1277778 }
    m.Points = append(
    m.Points, v)

    v = Vec2{ X: 0.6555556 , Y: -0.2194444 }
    m.Points = append(
    m.Points, v)

    v = Vec2{ X: 0.8111111 , Y: -0.3944445 }
    m.Points = append(
    m.Points, v)

    v = Vec2{ X: 0.9250001 , Y: -0.7416667 }
    m.Points = append(
    m.Points, v)

    v = Vec2{ X: 0.7194444 , Y: -0.9638889 }
    m.Points = append(
    m.Points, v)

    v = Vec2{ X: 0.4222223 , Y: -0.9805555 }
    m.Points = append(
    m.Points, v)

    v = Vec2{ X: 0.0138888 , Y: -0.9500000 }
    m.Points = append(
    m.Points, v)

    v = Vec2{ X: -0.3083333 , Y: -0.7833333 }
    m.Points = append(
    m.Points, v)

    v = Vec2{ X: -0.1027778 , Y: 0.5416666 }
    m.Points = append(
    m.Points, v)

    v = Vec2{ X: -0.3444445 , Y: 0.3777778 }
    m.Points = append(
    m.Points, v)

    v = Vec2{ X: -0.6305556 , Y: 0.2861111 }
    m.Points = append(
    m.Points, v)

    m.TriangleIndices = append(
    m.TriangleIndices, 8)
    m.TriangleIndices = append(
    m.TriangleIndices, 9)
    m.TriangleIndices = append(
    m.TriangleIndices, 10)
    m.TriangleIndices = append(
    m.TriangleIndices, 10)
    m.TriangleIndices = append(
    m.TriangleIndices, 11)
    m.TriangleIndices = append(
    m.TriangleIndices, 12)
    m.TriangleIndices = append(
    m.TriangleIndices, 12)
    m.TriangleIndices = append(
    m.TriangleIndices, 13)
    m.TriangleIndices = append(
    m.TriangleIndices, 14)
    m.TriangleIndices = append(
    m.TriangleIndices, 14)
    m.TriangleIndices = append(
    m.TriangleIndices, 15)
    m.TriangleIndices = append(
    m.TriangleIndices, 16)
    m.TriangleIndices = append(
    m.TriangleIndices, 16)
    m.TriangleIndices = append(
    m.TriangleIndices, 17)
    m.TriangleIndices = append(
    m.TriangleIndices, 10)
    m.TriangleIndices = append(
    m.TriangleIndices, 12)
    m.TriangleIndices = append(
    m.TriangleIndices, 14)
    m.TriangleIndices = append(
    m.TriangleIndices, 16)
    m.TriangleIndices = append(
    m.TriangleIndices, 10)
    m.TriangleIndices = append(
    m.TriangleIndices, 12)
    m.TriangleIndices = append(
    m.TriangleIndices, 16)
    m.TriangleIndices = append(
    m.TriangleIndices, 6)
    m.TriangleIndices = append(
    m.TriangleIndices, 7)
    m.TriangleIndices = append(
    m.TriangleIndices, 8)
    m.TriangleIndices = append(
    m.TriangleIndices, 8)
    m.TriangleIndices = append(
    m.TriangleIndices, 10)
    m.TriangleIndices = append(
    m.TriangleIndices, 6)
    m.TriangleIndices = append(
    m.TriangleIndices, 20)
    m.TriangleIndices = append(
    m.TriangleIndices, 0)
    m.TriangleIndices = append(
    m.TriangleIndices, 1)
    m.TriangleIndices = append(
    m.TriangleIndices, 18)
    m.TriangleIndices = append(
    m.TriangleIndices, 10)
    m.TriangleIndices = append(
    m.TriangleIndices, 17)
    m.TriangleIndices = append(
    m.TriangleIndices, 18)
    m.TriangleIndices = append(
    m.TriangleIndices, 6)
    m.TriangleIndices = append(
    m.TriangleIndices, 10)
    m.TriangleIndices = append(
    m.TriangleIndices, 5)
    m.TriangleIndices = append(
    m.TriangleIndices, 6)
    m.TriangleIndices = append(
    m.TriangleIndices, 18)
    m.TriangleIndices = append(
    m.TriangleIndices, 4)
    m.TriangleIndices = append(
    m.TriangleIndices, 5)
    m.TriangleIndices = append(
    m.TriangleIndices, 18)
    m.TriangleIndices = append(
    m.TriangleIndices, 18)
    m.TriangleIndices = append(
    m.TriangleIndices, 19)
    m.TriangleIndices = append(
    m.TriangleIndices, 20)
    m.TriangleIndices = append(
    m.TriangleIndices, 20)
    m.TriangleIndices = append(
    m.TriangleIndices, 1)
    m.TriangleIndices = append(
    m.TriangleIndices, 18)
    m.TriangleIndices = append(
    m.TriangleIndices, 1)
    m.TriangleIndices = append(
    m.TriangleIndices, 2)
    m.TriangleIndices = append(
    m.TriangleIndices, 18)
    m.TriangleIndices = append(
    m.TriangleIndices, 18)
    m.TriangleIndices = append(
    m.TriangleIndices, 2)
    m.TriangleIndices = append(
    m.TriangleIndices, 4)
    m.TriangleIndices = append(
    m.TriangleIndices, 4)
    m.TriangleIndices = append(
    m.TriangleIndices, 2)
    m.TriangleIndices = append(
    m.TriangleIndices, 3)

    makeAndReportOn(m, true)
}