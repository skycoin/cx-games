package entity

import "glfw"

import "app"
import "ccInput"
import "collision"



// ENTITY TYPES   (FIXME when we have const) 
var ENTITY_HERO        i32
var ENTITY_ROCKET      i32
var ENTITY_PARTICLE    i32
var ENTITY_EDITOR_NODE i32
	

// physics 
var ball Entity
var CamPos app.Vec3
var CamRot app.Vec3
var timeDel f32

// pools 
type Entity struct {
	Type i32
	Pos Vec2 // position 
	Rot f32  // rotation (around z axis) 
	Vel Vec2 // velocity 
	PolygonStart i32
	PolygonSize i32
	ExpiryByTime f32
	ExpiryByDistance f32


	gravity f32
	radius f32
}
var Ents []Entity



func Setup () () {
	str.print("entity.Setup()")

	// physics 
	ball = Entity{ radius: 0.05, gravity: 0.01 }
	CamPos = app.Vec3{ X: 0.0, Y: 0.0, Z: 0.0 }
	printf("CamPos.X: %v \n", CamPos.X)
}


func EntUpdate (tDelta f32) () {
	//str.print("entity.EntUpdate()")

	// physics 
	timeDel = tDelta
	// 		velocity & position adjust 
	ball.Vel.X = getVelocityChangesFromInput(ball.Vel.X, ccInput.GLFW_KEY_A, ccInput.GLFW_KEY_D)
	ball.Vel.Y = getVelocityChangesFromInput(ball.Vel.Y, ccInput.GLFW_KEY_S, ccInput.GLFW_KEY_W)
	ball.Vel.X = getVelocityChangesOnEdgeCollision(ball.Pos.X, ball.Vel.X, ball.radius, collision.ScreenEdgeL, collision.ScreenEdgeR)
	ball.Vel.Y = getVelocityChangesOnEdgeCollision(ball.Pos.Y, ball.Vel.Y, ball.radius, -1.0D, 1.0D)
	// when speed gets high enough, a simple velocity reversal isn't enough 
	// (jitters back & forth without getting back in bounds)
	ball.Pos.X = ensureEntirelyWithinBounds(ball.Pos.X, ball.radius, collision.ScreenEdgeL, collision.ScreenEdgeR)
	ball.Pos.Y = ensureEntirelyWithinBounds(ball.Pos.Y, ball.radius, -1.0D, 1.0D)
	
	// move 
	ball.Pos.X = f32.add(ball.Pos.X, ball.Vel.X)
	ball.Pos.Y = f32.add(ball.Pos.Y, ball.Vel.Y)
	tempPolling()
}


func Add (pos Vec2) () {
	var e Entity
	e = Entity{ Pos: pos }
	Ents = append(Ents, e)
	printf("entity.Add()   x: %f, y: %f \n", pos.X, pos.Y)
}










func tempPolling () () {
	rotateInc := 0.2

	if i32.eq(glfw.GetKey("window", ccInput.GLFW_KEY_A), 1) {
		CamPos.X = i32.add(CamPos.X, 0.0 - 0.001)
	} else
	if i32.eq(glfw.GetKey("window", ccInput.GLFW_KEY_D), 1) {
		CamPos.X = i32.add(CamPos.X, 0.001)
	} else {
		CamPos.X = 0.0
	}

	// x axis rotation 
	if i32.eq(glfw.GetKey("window", ccInput.GLFW_KEY_F2), 1) {
		CamRot.X = i32.add(CamRot.Y, 0.0 - rotateInc)
	} else
	if i32.eq(glfw.GetKey("window", ccInput.GLFW_KEY_F3), 1) {
		CamRot.X = i32.add(CamRot.Y, rotateInc)
	} else {
		CamRot.X = 0.0
	}

	// y axis rotation 
	if i32.eq(glfw.GetKey("window", ccInput.GLFW_KEY_Y), 1) {
		CamRot.Y = i32.add(CamRot.Y, 0.0 - rotateInc)
	} else
	if i32.eq(glfw.GetKey("window", ccInput.GLFW_KEY_N), 1) {
		CamRot.Y = i32.add(CamRot.Y, rotateInc)
	} else {
		CamRot.Y = 0.0
	}

	// forward/back translation 
	if i32.eq(glfw.GetKey("window", ccInput.GLFW_KEY_W), 1) {
		CamPos.Z = i32.add(CamPos.Z, 0.0 - 0.001)
	} else
	if i32.eq(glfw.GetKey("window", ccInput.GLFW_KEY_S), 1) {
		CamPos.Z = i32.add(CamPos.Z, 0.001)
	} else {
		CamPos.Z = 0.0
	}
}

func dampenNegativeMovement (currentVelocity f32, strength f32) (out f32) {
	out = f32.add(currentVelocity, app.FORCE * timeDel * strength)

	if out > 0.0 {
		out = 0.0
	}
}


func dampenPositiveMovement (currentVelocity f32, strength f32) (out f32) {
	out = f32.sub(currentVelocity, app.FORCE * timeDel * strength)

	if out < 0.0 {
		out = 0.0
	}
}


func getVelocityChangesFromInput (velocity f32, subKey i32, addKey i32) (out f32) {
	out = velocity

	//______________________________________________________________________ 
	if i32.eq(glfw.GetKey("window", addKey), 1) { //     speed up positively 
		if out < 0.0 {
			out = dampenNegativeMovement(out, 4.0)
		}

		out = f32.add(out, app.FORCE * timeDel)
	} else //___________________________________________ speed up negatively 
	if i32.eq(glfw.GetKey("window", subKey), 1) {
		if out > 0.0 {
			out = dampenPositiveMovement(out, 4.0)
		}

		out = f32.sub(out, app.FORCE * timeDel)
	} else { //__________________________________________ slow down 
		if out > 0.0 {
			out = dampenPositiveMovement(out, 1.0)
		} else
		if out < 0.0 {
			out = dampenNegativeMovement(out, 1.0)
		}
	}
}


// position, velocity, radius, negative value edge boundary, positive value edge boundary 
func getVelocityChangesOnEdgeCollision (pos f32, vel f32, rad f32, negEdge f64, posEdge f64) (out f32) {
	out = vel

	if f32.lteq(f32.sub(pos, rad), f64.f32(negEdge)) { 
		// hit neg edge 
		out = f32.abs(vel)
	} else
	if f32.gteq(f32.add(pos, rad), f64.f32(posEdge)) { 
		// hit pos edge 
		out = 0 - f32.abs(vel)
	}
}


// position, radius, negative value edge boundary, positive value edge boundary 
func ensureEntirelyWithinBounds (pos f32, rad f32, negEdge f64, posEdge f64) (out f32) {
	out = pos
	var ne f32
	var pe f32
	ne = f64.f32(negEdge)
	pe = f64.f32(posEdge)

	if f32.lteq(f32.sub(pos, rad), ne) { 
		// hit neg edge 
		out = f32.add(ne, rad)
	} else
	if f32.gteq(f32.add(pos, rad), pe) { 
		// hit pos edge 
		out = f32.sub(pe, rad)
	}
}
