package entity

import "glfw"

import "app"
import "ccInput"
import "collision"
import "environs"
import "mesh"



// TYPES   (FIXME when we have constants) 
var TYPE_HERO        i32 = 1
var TYPE_BULLET      i32 = 2
var TYPE_ROCKET      i32 = 3
var TYPE_PARTICLE    i32 = 4
var TYPE_EDITOR_NODE i32 = 5

// MODES 
var MODE_STATIONARY      i32 = 1
var MODE_MOVING_STRAIGHT i32 = 2
var MODE_ROAMING         i32 = 3
var MODE_ATTACKING       i32 = 4
var MODE_DYING           i32 = 5
var MODE_DEAD            i32 = 6
// consider that maybe corpse needs to remain visible....
// (then _DEAD != inactive/disabled (the Unity term) ) 
	
// physics 
var CamPos  app.Vec3
var CamRot  app.Vec3
var timeDel f32

// extents
var HeroExtents   Vec2 = Vec2{ X: 0.08,  Y: 0.04 }
var BulletExtents Vec2 = Vec2{ X: 0.02,  Y: 0.004 }
var RocketExtents Vec2 = Vec2{ X: 0.01,  Y: 0.05 }
var NodeExtents   Vec2 = Vec2{ X: 0.009, Y: 0.009 }

// pools 
type Entity struct {
	Type i32
	Pos Vec2 // position 
	//Rot f32  // rotation (around z axis) 
	Radius f32
	Extents Vec2 // FIXME?...this obviates need for radius? 
	Vel Vec2 // velocity 
	PolygonStart i32
	PolygonSize i32
	Mode i32
	NextMode i32
	TimeToNextMode f32
	DistanceToNextMode f32
}
var Ents []Entity

var PickedTrianglesNextId i32
var PickedTriangle []i32



func Setup () () {
	str.print("entity.Setup()")

	// these values only used if PickedTrianglesNextId >= 3 
	PickedTriangle = append(PickedTriangle, 0)
	PickedTriangle = append(PickedTriangle, 1)
	PickedTriangle = append(PickedTriangle, 2)

	var pos Vec2
	pos = Vec2{
		X: 0.0, 
		Y: 0.0}
	
	var ent Entity
	ent = Entity{ 
		Type: TYPE_HERO, 
		Pos: pos, 
		Extents: HeroExtents }
	
	Add(ent)
	CamPos = app.Vec3{ X: 0.0, Y: 0.0, Z: 0.0 }
	printf("CamPos.X: %v \n", CamPos.X)
}


func Add (ent Entity) () {
	//printf("entity.Add()   x: %f, y: %f \n", pos.X, pos.Y)
	Ents = append(Ents, ent)
	
	// set radius by extents 
	// (FIXME?  it's not accurate.  corners lie outside of radius) 
	if ent.Extents.X > ent.Extents.Y {
		ent.Radius = ent.Extents.X
	} else {
		ent.Radius = ent.Extents.Y
	}
}


func EntUpdate (tDelta f32, currTime f32) () {
	//str.print("entity.EntUpdate()")
	
	// physics 
	timeDel = tDelta
	// 		velocity & position adjust 
	Ents[0].Vel.X = getVelocityChangesFromInput(Ents[0].Vel.X, ccInput.GLFW_KEY_A, ccInput.GLFW_KEY_D)
	Ents[0].Vel.Y = getVelocityChangesFromInput(Ents[0].Vel.Y, ccInput.GLFW_KEY_S, ccInput.GLFW_KEY_W)
	Ents[0].Vel.X = getVelocityChangesOnEdgeCollision(Ents[0].Pos.X, Ents[0].Vel.X, Ents[0].Radius, collision.ScreenEdgeL, collision.ScreenEdgeR)
	Ents[0].Vel.Y = getVelocityChangesOnEdgeCollision(Ents[0].Pos.Y, Ents[0].Vel.Y, Ents[0].Radius, -1.0D, 1.0D)
	// when speed gets high enough, a simple velocity reversal isn't enough 
	// (jitters back & forth without getting back in bounds)
	Ents[0].Pos.X = ensureEntirelyWithinBounds(Ents[0].Pos.X, Ents[0].Extents.X, collision.ScreenEdgeL, collision.ScreenEdgeR)
	Ents[0].Pos.Y = ensureEntirelyWithinBounds(Ents[0].Pos.Y, Ents[0].Extents.Y, -1.0D, 1.0D)
	
	// moves 
	var i i32
	for i = 0; i < len(Ents); i++ {
		// mode changes 
		if Ents[i].TimeToNextMode != 0 && 
			Ents[i].TimeToNextMode <= currTime {
			Ents[i].Mode = Ents[i].NextMode
		}			
		
		// movement 
		if 	i32.uneq(Ents[i].Mode, MODE_DEAD) &&
			i32.uneq(Ents[i].Mode, MODE_STATIONARY) {
			
			// move 
			Ents[i].Pos.X = f32.add(Ents[i].Pos.X, Ents[i].Vel.X)
			Ents[i].Pos.Y = f32.add(Ents[i].Pos.Y, Ents[i].Vel.Y)
			
			if Ents[i].Type == TYPE_HERO {
				//str.print("HERO")
			} else {
				var hit bool
				var other Entity
				hit, other = checkForHitDownStream(i)
				if hit {
					Ents[i].Mode = MODE_DEAD
					other.Mode   = MODE_DEAD
					continue
				}
			}
		}
	}
	
	//pollCameraControlKeys()
}


// id is the moving entity, which triggered the need to scan other entities 
func checkForHitDownStream (id i32) (hit bool, other Entity) {
	var o i32 // other 
	for o = id + 1; o < len(Ents); o++ {
		hit = pairIsTouching(id, o)
		if hit {
			//str.print("hit!")
			other = Ents[o]
		}
	}
}


func pairIsTouching (id i32, o i32) (hit bool) {
	hit = true // lie for a moment 
	
	if f32.lt(f32.add(Ents[o].Pos.X, Ents[o].Extents.X), 
		f32.sub(Ents[id].Pos.X, Ents[id].Extents.X)) ||
		f32.gt(f32.sub(Ents[o].Pos.X, Ents[o].Extents.X), 
		f32.add(Ents[id].Pos.X, Ents[id].Extents.X)) {
		
		hit = false
	}
}


func pollCameraControlKeys () () {
	rotateInc := 0.2

	if i32.eq(glfw.GetKey("window", ccInput.GLFW_KEY_A), 1) {
		CamPos.X = i32.add(CamPos.X, 0.0 - 0.001)
	} else
	if i32.eq(glfw.GetKey("window", ccInput.GLFW_KEY_D), 1) {
		CamPos.X = i32.add(CamPos.X, 0.001)
	} else {
		CamPos.X = 0.0
	}

	// x axis rotation 
	if i32.eq(glfw.GetKey("window", ccInput.GLFW_KEY_F2), 1) {
		CamRot.X = i32.add(CamRot.Y, 0.0 - rotateInc)
	} else
	if i32.eq(glfw.GetKey("window", ccInput.GLFW_KEY_F3), 1) {
		CamRot.X = i32.add(CamRot.Y, rotateInc)
	} else {
		CamRot.X = 0.0
	}

	// y axis rotation 
	if i32.eq(glfw.GetKey("window", ccInput.GLFW_KEY_Y), 1) {
		CamRot.Y = i32.add(CamRot.Y, 0.0 - rotateInc)
	} else
	if i32.eq(glfw.GetKey("window", ccInput.GLFW_KEY_N), 1) {
		CamRot.Y = i32.add(CamRot.Y, rotateInc)
	} else {
		CamRot.Y = 0.0
	}

	// forward/back translation 
	if i32.eq(glfw.GetKey("window", ccInput.GLFW_KEY_W), 1) {
		CamPos.Z = i32.add(CamPos.Z, 0.0 - 0.001)
	} else
	if i32.eq(glfw.GetKey("window", ccInput.GLFW_KEY_S), 1) {
		CamPos.Z = i32.add(CamPos.Z, 0.001)
	} else {
		CamPos.Z = 0.0
	}
}


func dampenNegativeMovement (currentVelocity f32, strength f32) (out f32) {
	out = f32.add(currentVelocity, app.FORCE * timeDel * strength)

	if out > 0.0 {
		out = 0.0
	}
}


func dampenPositiveMovement (currentVelocity f32, strength f32) (out f32) {
	out = f32.sub(currentVelocity, app.FORCE * timeDel * strength)

	if out < 0.0 {
		out = 0.0
	}
}


func getVelocityChangesFromInput (velocity f32, subKey i32, addKey i32) (out f32) {
	out = velocity

	//______________________________________________________________________ 
	if i32.eq(glfw.GetKey("window", addKey), 1) { //     speed up positively 
		if out < 0.0 {
			out = dampenNegativeMovement(out, app.DAMP_FACTOR_STRONG)
		}

		out = f32.add(out, app.FORCE * timeDel)
		if f32.gt(out, app.MAX_HERO_SPEED) { // enforce speed limit 
			out = app.MAX_HERO_SPEED
		}
	} else //___________________________________________ speed up negatively 
	if i32.eq(glfw.GetKey("window", subKey), 1) {
		if out > 0.0 {
			out = dampenPositiveMovement(out, app.DAMP_FACTOR_STRONG)
		}

		out = f32.sub(out, app.FORCE * timeDel)
		if f32.lt(out, 0.0 - app.MAX_HERO_SPEED) { // enforce speed limit 
			out = 0.0 - app.MAX_HERO_SPEED
		}
	} else { //__________________________________________ slow down 
		if out > 0.0 {
			out = dampenPositiveMovement(out, app.DAMP_FACTOR_WEAK)
		} else
		if out < 0.0 {
			out = dampenNegativeMovement(out, app.DAMP_FACTOR_WEAK)
		}
	}
}


// position, velocity, radius, negative value edge boundary, positive value edge boundary 
func getVelocityChangesOnEdgeCollision (pos f32, vel f32, rad f32, negEdge f64, posEdge f64) (out f32) {
	out = vel

	if f32.lteq(f32.sub(pos, rad), f64.f32(negEdge)) { 
		// hit neg edge 
		out = f32.abs(vel)
	} else
	if f32.gteq(f32.add(pos, rad), f64.f32(posEdge)) { 
		// hit pos edge 
		out = 0 - f32.abs(vel)
	}
}


// position, radius, negative value edge boundary, positive value edge boundary 
func ensureEntirelyWithinBounds (pos f32, rad f32, negEdge f64, posEdge f64) (out f32) {
	out = pos
	var ne f32
	var pe f32
	ne = f64.f32(negEdge)
	pe = f64.f32(posEdge)

	if f32.lteq(f32.sub(pos, rad), ne) { 
		// hit neg edge 
		out = f32.add(ne, rad)
	} else
	if f32.gteq(f32.add(pos, rad), pe) { 
		// hit pos edge 
		out = f32.sub(pe, rad)
	}
}


func MakeNewTriangleFromPicked() () {
str.print("MakeNewTriangleFromPicked")
	var a i32
	var b i32
	var c i32
	a = PickedTriangle[0]
	b = PickedTriangle[1]
	c = PickedTriangle[2]

	mesh.MakeNewTriangle(Ents[a].Pos, Ents[b].Pos, Ents[c].Pos)
}


//for i := 0; i32.lt(i, PickedTrianglesNextId); i++ {
