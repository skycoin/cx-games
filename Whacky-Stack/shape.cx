package shape

import "app"
import "map"



var NUM_SHAPES i32 = 7 // (4 of them are mirrored) 

var SHAPE_BEAM i32
var SHAPE_L i32
var SHAPE_L_MIRROR i32
var SHAPE_ZIGZAG i32
var SHAPE_ZAGZIG i32
var SHAPE_MIDTINE i32
var SHAPE_BLOCK i32

type Shape struct {
	Cells [5][5]bool
}

var Cells [5][5]bool
var rp    [5][5]bool // rotated piece (temp scratchpad) 
//var Curr Shape

// FIXME:  
//		do pos initialization each time new piece starts at top
//		DON'T set PlayerPos directly, as fitting rules need application 
// 		flesh out MovePiece()
var PlayerPos Vec2I = Vec2I{ X: 2, Y: map.NUM_CELLS_Y - 5 }


func Setup () {
	str.print("shape.Setup ()")
	init(//Curr,
		0, 0, 0, 0, 0,
		0, 0, 0, 0, 0,
		0, 1, 1, 1, 0,
		0, 0, 1, 0, 0,
		0, 0, 0, 0, 0)
}


func MovePiece (v Vec2I) {
	// ensure within side edges
	// LOCK (and spawn new piece) when touching bottom, or other blocks) 
}


func getBool (i i32) (out bool) {
	if i != 0 {
		out = true
	}
}


func init (//foo Shape,
	a i32, b i32, c i32, d i32, e i32,
	f i32, g i32, h i32, i i32, j i32,
	k i32, l i32, m i32, n i32, o i32,
	p i32, q i32, r i32, s i32, t i32,
	u i32, v i32, w i32, x i32, y i32) {
	
	str.print("shape.init ()")
	

	
	Cells[0][0] = getBool(a)
	Cells[0][1] = getBool(b)
	Cells[0][2] = getBool(c)
	Cells[0][3] = getBool(d)
	Cells[0][4] = getBool(e)

	Cells[1][0] = getBool(f)
	Cells[1][1] = getBool(g)
	Cells[1][2] = getBool(h)
	Cells[1][3] = getBool(i)
	Cells[1][4] = getBool(j)

	Cells[2][0] = getBool(k)
	Cells[2][1] = getBool(l)
	Cells[2][2] = getBool(m)
	Cells[2][3] = getBool(n)
	Cells[2][4] = getBool(o)

	Cells[3][0] = getBool(p)
	Cells[3][1] = getBool(q)
	Cells[3][2] = getBool(r)
	Cells[3][3] = getBool(s)
	Cells[3][4] = getBool(t)

	Cells[4][0] = getBool(u)
	Cells[4][1] = getBool(v)
	Cells[4][2] = getBool(w)
	Cells[4][3] = getBool(x)
	Cells[4][4] = getBool(y)
}


func Rotate () { // j = the y in rp 
	j := 4
	for y := 0; y < 5; y++ {
		for x := 0; x < 5; x++ {
			rp[x][j] = Cells[y][x]
		}
		
		j--	
	}
	
	Cells = rp
}
