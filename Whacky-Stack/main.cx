package main

import "app"
import "gl"
import "glfw"

import "draw"
import "inputs"
import "shape"
import "time"







/* 

TODO:
REQUIRED FEATURES:

* game over state & overlay 
* menu
	* toggle showing of next piece
	* toggle random pre-cluttered playfield
	* slider? for how many rows of clutter



WISHLIST:
   (not necessary, but would be nice) 

* guide lines down to landing 
* instadrop action 
* Smooth motion interpolations (prioritized) 
	* row collapsing
	* player moves
	* player rotations (problem: making the piece's movement look more like physical reality would make some valid moves look crazy.  But while smoothly turning, the piece could be drawn as a transparent white'ish ghost, which would go a long way towards making the "gear teeth"-passing-through-each-other look sensible)
	
* animate exploding the row blocks 

* score delta text (with "X3" modifiers ) pops up near the exploding rows.  possibly travelling
up to the total score printout

* animate clearing old playfield and setting up the new one, between games.  maybe they all shoot out of a point on the screen (maybe logo) and fly/rotate to the final positions.  like dealing out cards 

* when player tries an invalid rotation, auto-push the player piece away from collisions if possible.  would make the game feel a lot more fluid.  so that player doesn't have to scramble to move to valid position and then press rotate AGAIN.  which could easily result in the user pressing rotate at least 3 more times, ON TOP OF the movements in between.  like when controlling SHAPE_BEAM

* error text when player tries invalid moves & rotations (probably JUST rotations, because invalid moves are too obvious).  maybe stifle any text popups that would be triggered by key repeat events

* animated startup/menu screen
		would be cool to show big versions of all the shapes/pieces, circularly rotating around the menu
		
* high scores list
		animation for when you break records 

*/







func mouseButton (window str, key i32, action i32, mods i32) {
	var x f64
	var y f64
	
	x, y = glfw.GetCursorPos("window")
	/*if key == glfw.MouseButtonLeft {
		if action == glfw.Press {
		}
	}*/

	/*if key == glfw.MouseButtonRight {
		if action == glfw.Press {
		}
	}*/
}


func init () {
	app.Init()
	shape.Init()
	draw.Init()
	inputs.Init()
}


func main () {
	glfw.Init()

	glfw.CreateWindow("window", app.WIDTH, app.HEIGHT, app.NAME)
	glfw.MakeContextCurrent("window")

	gl.Init()
	program := gl.CreateProgram()
	gl.LinkProgram(program)

	init()


	//testvalue= [][]i32.read(dropsArray,0)
	//str.print(str.concat("testvalue: ", i32.str(testvalue)))


	gl.UseProgram(program)

	gl.Enable(gl.BLEND)
	gl.BlendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA)
	gl.DepthMask(true)

	for bool.not(glfw.ShouldClose("window")) {
		time.Update()
		
		gl.ClearColor(0.0, 0.0, 0.0, 1.0)
		gl.Clear(gl.COLOR_BUFFER_BIT)

		gl.Enable(gl.TEXTURE_2D)

		gl.Color3f(1.0, 1.0, 1.0)

		draw.PicAtScale(draw.PicBackground, 0.0, 0.0, 1.0, 1.0)
		draw.PlayField()
		draw.PlayerPiece()
		
		if inputs.ShowingNextShape {
			draw.NextShape()
		}
		
		//gltext.Printf("Roboto50", 0.0, 0.0, "whacky stack")
		
		glfw.PollEvents()
		glfw.SwapBuffers("window")
	}
}
