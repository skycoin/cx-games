package inputs

import "glfw"

import "app"
import "map"
import "menu"
import "shape"
import "space"



// mouse 
var MousePointer       Vec2
var MousePointerX64    f64
var MousePointerY64    f64
var mouseMoveThreshold f64 = 85.0D // for Whacky Stack's blocky movement 

// keys 
var	GLFW_KEY_W     i32 = 87
var	GLFW_KEY_A     i32 = 65
var	GLFW_KEY_S     i32 = 83
var	GLFW_KEY_D     i32 = 68

var GLFW_KEY_SPACE i32 = 32



func Init () {
	str.print("inputs.Init ()")

	// callbacks 
	glfw.SetKeyCallback        ("window", "onKeyEvent")
	glfw.SetMouseButtonCallback("window", "onMouseButtonEvent")
	glfw.SetCursorPosCallback  ("window", "onCursorPosEvent")
}


// i'm not really happy with the default timing that GLFW provides.
// so later i'll probably make the delay until repeat a little less,
// and make the repeats maybe around twice as fast
//var timeSinceAnyKeyEvent f64
//var timeToRepeat
func Update () {
	//str.print("inputs.Update()")
	if GoRight() {
		
	}
}


func PointerInYPixelRange (lesser f32, greater f32) (out bool) {
	if MousePointerY64 < f32.f64(greater) &&
		MousePointerY64 >= f32.f64(lesser) {
			
		out = true
	}
}


func GoLeft () (out bool) {
	if i32.eq(glfw.GetKey("window", GLFW_KEY_A), 1) ||
		i32.eq(glfw.GetKey("window", GLFW_KEY_LEFT), 1) {
		out = true
	}
}
func GoRight () (out bool) {
	if i32.eq(glfw.GetKey("window", GLFW_KEY_D), 1) ||
		i32.eq(glfw.GetKey("window", GLFW_KEY_RIGHT), 1) {
		out = true
	}
}
func GoDown () (out bool) {
	if i32.eq(glfw.GetKey("window", GLFW_KEY_S), 1) ||
		i32.eq(glfw.GetKey("window", GLFW_KEY_DOWN), 1) {
		out = true
	}
}
func GoUp () (out bool) {
	if i32.eq(glfw.GetKey("window", GLFW_KEY_W), 1) ||
		i32.eq(glfw.GetKey("window", GLFW_KEY_UP), 1) {
		out = true
	}
}


func Back (key i32) (out bool) {
	if i32.eq(glfw.GetKey("window", GLFW_KEY_ESCAPE), 1) ||
		i32.eq(glfw.GetKey("window", GLFW_KEY_HOME), 1) {
		out = true
	}
}


// mouse buttons 
func onMouseButtonEvent (window str, button i32, action i32, mods i32) {
	if /* release */ action == 0 {
	} else 
	if /* press   */ action == 1 {
		//printf("onMouseButtonEvent() - %f, %f \n", MousePointer.X, MousePointer.Y)

		if button == 0 { // LMB 
			if app.Mode <= app.MODE_MENU_OPTIONS { // in a menu 
				respondToMenu()
			}
			
			shape.PlayerRotate(-1)
		} else
		if button == 1 { // RMB 
			shape.PlayerRotate(1)
		} else { // MMB or extra buttons (would be unwise to require more than 3 buttons) 
		}
	}
}


// mouse position 
var oldV Vec2
var old64 Vec2F64
var deltaX f32
var deltaY f32
var deltaX64 f64
var deltaY64 f64
var dist Vec2F64 // distance since latest piece movement 
func onCursorPosEvent (window str, x f64, y f64) {
	oldV.X = MousePointer.X
	oldV.Y = MousePointer.Y
	old64.X = MousePointerX64
	old64.Y = MousePointerY64
	

	MousePointerX64 = x
	MousePointerY64 = y

	var mX f32
	mX = f32.div(f64.f32(x), i32.f32(app.ScreenSizeInPixels.X))
	mX = f32.mul(mX, f32.mul(f64.f32(space.ScreenEdgeR), 2.0))
	MousePointer.X = f32.add(f64.f32(space.ScreenEdgeL), mX)

	var mY f32
	mY = f32.div(f64.f32(y), i32.f32(app.ScreenSizeInPixels.Y))
	mY = f32.mul(mY, 2.0)
	MousePointer.Y = f32.sub(1.0, mY)
	

	deltaX = f32.sub(MousePointer.X, oldV.X)
	deltaY = f32.sub(MousePointer.Y, oldV.Y)
	deltaX64 = f64.sub(x, old64.X)
	deltaY64 = f64.sub(y, old64.Y)


	// blocky mouse movement 
	dist.X = f64.add(dist.X, deltaX64)
	dist.Y = f64.add(dist.Y, deltaY64)
	
	if dist.X > mouseMoveThreshold {
		shape.MovePieceBy(1, 0)
		dist.X = 0.0D
		dist.Y = 0.0D
	} else 
	if dist.X < -mouseMoveThreshold {
		shape.MovePieceBy(-1, 0)
		dist.X = 0.0D
		dist.Y = 0.0D
	}	

	if dist.Y > mouseMoveThreshold {
		shape.MovePieceBy(0, -1)
		dist.X = 0.0D
		dist.Y = 0.0D
	} else
	if dist.Y < -mouseMoveThreshold {
		//shape.MovePieceBy(0, 1)
		dist.X = 0.0D
		dist.Y = 0.0D
	}	
	
	//printf("onCursorPosEvent %f, %f \n", deltaX64, deltaY64)
	//printf("onCursorPosEvent %f, %f \n", MousePointer.X, MousePointer.Y)
}


// keys 
func onKeyEvent (window str, key i32, scancode i32, action i32, mods i32) {
	// action == 0, release 
	// action == 1, press 
	// action == 2, is an autorepeat event, generated by keys that are held longer than a second

	if true { //action != 2 { // (not a repeat) 
		if action >= 1 { // (press) 
			//str.print("-------------------------------------PRESS (not a repeat)")

			if key == 53 { // GLFW_KEY_5 
				// close 
				str.print("^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ QUITTING GAME ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^")
				glfw.SetShouldClose("window", true)
			} else
			if eventLeft(key) {
				shape.MovePieceBy(-1, 0)
			} else
			if eventRight(key) {
				shape.MovePieceBy(1, 0)
			} else
			if eventUp(key) {
				//shape.MovePieceBy(0, 1)
			} else
			if eventDown(key) {
				shape.MovePieceBy(0, -1)
			} else
			if eventRotateLeft(key) {
				shape.PlayerRotate(-1)
			} else
			if eventRotateRight(key) {
				shape.PlayerRotate(1)			
			}

			maybeToggleMousePointer(key)
		}
	}
}


var wantMousePointer bool = true
func maybeToggleMousePointer (key i32) {
	//i32.print(key)

	if Back(key) ||
		key == 257 || // GLFW_KEY_ENTER
		key == 258 || // GLFW_KEY_TAB 
		key == 259 { // GLFW_KEY_BACKSPACE 

		app.Mode = app.MODE_MENU_MAIN
		wantMousePointer = false
		toggleMousePointer()
	}
}


func toggleMousePointer () {
	wantMousePointer = !wantMousePointer

	if bool.eq(wantMousePointer, true) {
		glfw.SetInputMode("window", glfw.Cursor, glfw.CursorNormal)
	} else {
		glfw.SetInputMode("window", glfw.Cursor, glfw.CursorDisabled)
	}
}


func eventLeft (key i32) (out bool) {
  if i32.eq(key, GLFW_KEY_A) ||
    i32.eq(key, GLFW_KEY_LEFT) {
    out = true
  }
}

func eventRight (key i32) (out bool) {
  if i32.eq(key, GLFW_KEY_D) ||
    i32.eq(key, GLFW_KEY_RIGHT) {
    out = true
  }
}

func eventDown (key i32) (out bool) {
  if i32.eq(key, GLFW_KEY_S) ||
    i32.eq(key, GLFW_KEY_DOWN) {
    out = true
  }
}

func eventUp (key i32) (out bool) {
  if i32.eq(key, GLFW_KEY_W) ||
    i32.eq(key, GLFW_KEY_UP) {
    out = true
  }
}

func eventRotateLeft (key i32) (out bool) {
  if i32.eq(key, GLFW_KEY_Q) ||
  	i32.eq(key, GLFW_KEY_LEFT_SHIFT) ||
    i32.eq(key, GLFW_KEY_RIGHT_SHIFT) {
    out = true
  }
}

func eventRotateRight (key i32) (out bool) {
  if i32.eq(key, GLFW_KEY_E) ||
  	i32.eq(key, GLFW_KEY_LEFT_CONTROL) ||
    i32.eq(key, GLFW_KEY_RIGHT_CONTROL) {
    out = true
  }
}


func respondToMenu () {
	var s str
	var i i32
	s, i = menu.GetClickedItem(app.Mode)

	if s == menu.Play {
		toggleMousePointer()
		shape.StartNewGameSession
		app.Mode = app.MODE_PLAYING
	} else
	if s == menu.Options {
		app.Mode = app.MODE_MENU_OPTIONS
	} else
	if s == menu.Quit {
		glfw.SetShouldClose("window", true)
	} else
	if s == menu.ShowNextShapeText + "YES" {
		    menu.ShowNextShape = false
		menu.Items[app.Mode][i].Text = menu.ShowNextShapeText + "NO"
	} else
	if s == menu.ShowNextShapeText + "NO" {
		    menu.ShowNextShape = true
		menu.Items[app.Mode][i].Text = menu.ShowNextShapeText + "YES"
	} else
	if s == menu.DebrisHeightText {
		menu.DebrisHeight = menu.SetSliderValue(i, f64.f32(MousePointerX64))
		shape.StartNewGameSession()
	}
}
